<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Doing Right Things</title>
    <link>http://www.leyafo.com/</link>
    <description>Recent content on Doing Right Things</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 14 Aug 2016 12:10:03 +0800</lastBuildDate>
    <atom:link href="http://www.leyafo.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>我看奥运会</title>
      <link>http://www.leyafo.com/post/2016-08-14-olympics-I-say/</link>
      <pubDate>Sun, 14 Aug 2016 12:10:03 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2016-08-14-olympics-I-say/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;a blatant attempt to influence your music taste.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;今天早上看到关于中国游泳选手尿检阳性的消息。我当时的感受就是：”干得漂亮！最好能彻底查一查那些患有心脏病的选手到底是怎么回事“。有人说你这不爱国。我想说，现在的年轻人啊，你可以去爱生活，爱你身边的人，爱这个世界，为什么偏偏要做爱国这么 low 的事情呢？奥运会拿的那几块牌子对你的生活有任何影响吗？你跟着瞎起哄还上升到民族大义，傻不傻？&lt;/p&gt;

&lt;p&gt;我个人有记忆以来大概是从 2000 年开始看奥运会的。这么多年过去了，我仍然没觉得这个运动会有多好看。 2008 我们举全国之力举办的那次我也没觉得有多好看。我个人最喜欢的一届是 2012 年的伦敦奥运会，因为开幕式和闭幕式有我喜欢的英伦摇滚演出。奥运会其实只是一个体育界的演出而已，国家荣誉只是媒体灌输给我们的观念。奥运会给我们的生活带来不了任何的变化。想想看中国参加奥运会这么多年了，我们国民的身体素质上升了多少？我们从小到大学校里像样的运动场有多少？我们平常会的运动除了跑步还有哪些？ 为什么跳广场舞的大妈越来越多？&lt;/p&gt;

&lt;p&gt;这些问题的存在无时无刻不在提醒着我们是一个在运动和国民身体素质都很弱的国家。我们从小到大的学校不仅仅没有像样的运动场所，连像样的的体育老师也没有，甚至连体育课的都要被其他课程抢走。奥运会上表演的那些项目大部分在我们平常的生活里面是消失掉的。这些消失掉的项目大部分并不是因为门槛有多高，有多么的专业。而是因为我们真的没地方玩，没有人教过我们怎么去安全的去玩。在学校里面我们有少量的运动设施，还可以找到一些一起运动的同学。工作后我们连找个地方做跑步这样简单的运动都不是那么容易，还要担心下雾霾对我们的影响。中国自己参加和举办的各种运动会搞的如火如荼，而我们大部分人都没有学会去怎样运动，学会去怎样锻炼出一个强健的体魄。&lt;/p&gt;

&lt;p&gt;奥运会是个很好的活动，让各类运动高手同台竞技，给我们普通人带来观赏性的同时也让我们由衷的赞美运动员那强健的体魄。顶级运动员经过日复一日的训练，达到完美动作给我们普通人带来了非常好的示范性榜样。但现在，我们在看奥运会到底是在看什么？是在看娱乐表演？还是在看脸、看腹肌？游泳这种的这么平常的运动每年我们都要淹死多少人？我们有多少人到了 20 岁甚至连游泳都不会？国家积极参与奥运这么多年，从来就没有想过向普通大众去推广这些运动。举国体制办的奥运会让那么一小部分人每天像牛耕地一样训练，最开始用鞭子抽，后来发现用鞭子抽不动了，牛的速度上不去了，这时便开始往牛的屁股上注射药物。运动竞技理想的状态应该是让喜欢运动的人去做他最擅长的事情，配合各种等级的联赛让不同级别水平有一个公平竞技的机会。顶级的运动员像走台阶一样一级一级的走到最顶级联赛上去。我们现在根本就没有这种联赛机制。好不容易搞了个比赛，我们却经常能听到高中生通过改年龄去和初中生打比赛的例子。这就导致了我们陪养出来的运动员没有经历过次级联赛，直接往顶级联赛上跑，比赛时却发现没有那么多比赛经验。这时候用药显然是个比较好的捷径，因为一开始他们就是走捷径的，在再往前走一步又何妨。&lt;/p&gt;

&lt;p&gt;在动物世界里面狮子捕捉猎物的那种冲击力与爆发力非常炫目，还有猎豹全速冲击时身上的肌肉随风一样飘荡，这是大自然带给我们的美。足球场上运动员在场上奔跑，刘翔飞跃跨栏，短跑运动员发令枪响时冲击的那一瞬间，这些画面都很美，都是人类在展示大自然给我们的美。我们见过无数运动员泪洒赛场，为了这块奖牌付出的努力有多少是自己真正想要的呢？奥运冠军退休后乞讨，贫苦山区孩子为了生活而当运动员，这种苦大仇深的故事我们听过的已经太多了。每次一想到这些，我再看奥运会我就觉得特别糟心。我更愿意去看经常熬夜通宵面容憔悴的网吧少年打电竞，至少那里有很大一部分人是真正喜欢做这个事情的。那些迫不得已注射药物的运动员有几个是真正喜欢这个运动，享受比赛的？我们真的不需要那么多中看不中用的牌子，把运动还给我们普通大众，让喜欢运动的人去做运动员，少几个泪洒赛场苦大仇深的运动员，多几个洪荒少女，这才是我们需要的。&lt;/p&gt;

&lt;h2 id=&#34;关于运动本身&#34;&gt;关于运动本身&lt;/h2&gt;

&lt;p&gt;我个人因为在两年前身体上的一些小毛病在机缘巧合的情况下开始去健身房健身。我个人并不是太喜欢在健身时的那种感觉，那种运动的感觉让人不那么舒适，很吃力，我喜欢健身完之后的那种感觉。这就好比你顶着巨大的压力前行，等去掉这些压力以后再继续前行，你会觉得很轻松，觉得自己又变强壮了，那种强壮的感觉真的很好。我从小到大从来没有踢过足球，到工作后才和同事踢过几次小场地足球。我这种烂水平在场上摸不到几次球，甚至有时要被派去当守门员。尽管如此，我仍然很喜欢这个运动。十几个人在场上为了一只球到处追，到处跑。有时把球带到球门前，临门一脚打进去时肾上腺素飙升那种刺激的感觉真的很好，很难在平常的生活中找到那种感觉。这就是我现在对于运动的看法，我不知道其他喜欢运动的人有没有更高的境界，我很想知道。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开发笔记(2) － 部署遇到的麻烦事儿</title>
      <link>http://www.leyafo.com/post/2016-08-05-deployment-as-chore/</link>
      <pubDate>Fri, 05 Aug 2016 11:25:19 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2016-08-05-deployment-as-chore/</guid>
      <description>

&lt;p&gt;我们现在用 Rails 做开发，线上的环境配置非常繁琐。到现在仍然没有找到一个可以快速 setup 一个 server 的解决方案。以下是我们在部署一个新的 server 时要做的一些麻烦事，我希望有一天能够在半小时内不用 ssh 登陆服务器就能把这些事情做好。&lt;/p&gt;

&lt;h4 id=&#34;一-服务器-setup&#34;&gt;一、服务器 setup&lt;/h4&gt;

&lt;p&gt;我们现在全线使用阿里云来配置 qa, production, db, backup 这些环境。每次新拿到一个 vps，我们做的第一件事情就是配置 ssh，创建相关人员账户，设置 public key，关闭免密码登录。这一系列的动作我们使用了 &lt;a href=&#34;https://www.chef.io/&#34;&gt;chef&lt;/a&gt; 来做这件事情，基本上做到了一键设置。还有像一些 bash，hosts 文件配置，安装一些常用软件等着一些比较简单的事情 chef 也做得很好。但 chef 能做好的事情也仅仅只有这一些而已。一旦我们需要安装类似于 rvm，ruby，postgresql 这样配置比较复杂的软件时 chef 就完全不能胜任了。其中有很大一方面的原因是 chef 配置非常之复杂、繁琐。里面各种各样的依赖，和每个 node 之间相互不同的 attributes 很让人焦头烂额。每次修改配置的时间超过了 setup 一个 server 的时间。如果长时间不去维护里面的 cookbook，过一段后又要重新去翻文档配置。这就是 chef 的问题，它带来的问题比要解决的问题更多。&lt;/p&gt;

&lt;h4 id=&#34;二-ruby-环境-setup&#34;&gt;二、ruby 环境 setup&lt;/h4&gt;

&lt;p&gt;我们现在用的是 rvm + ruby 的组合来运行我们的 app。rvm 主要的作用是管理不同的 ruby 版本，这几乎是所有解释型语言的通病，需要有一个版本管理工具来管理不同版本的解释器。静下心来想一想，我们其实并不需要多个ruby 版本。尤其是在服务器的环境里面很难会容许不同版本的 ruby 共存这样复杂的情况。因此 rvm 最主要的功能实际上我们是不需要的。我们尝试过在 server 自己手动编译一个指定的版本，但这样带来的问题是安装 gem 包需要 sudo 权限。也尝试过更改 gem 所在目录的权限，但一些 gem 有可执行文件，需要放在系统的 bin 目录下，这也需要 sudo 权限，这个再更改 bin 的目录权限就不那么适合了。我们现在的解决方案是使用 rbenv，这个工具和 rvm 做一样的事情，但安装配置比 rvm 要简单很多。到这时我才发现 rvm 和 rbenv 这样的工具更重要的是解决 gem 包的存放问题。&lt;/p&gt;

&lt;h4 id=&#34;三-app-setup&#34;&gt;三、app setup&lt;/h4&gt;

&lt;p&gt;我们的 rails 应用现在使用的是 capistrano 这个工具来做一键化部署。这是一个很复杂的工具，每次部署时会输出一大堆不太容易看明白的 log。尽管如此，它还是可靠的。基本上做到了一键化部署，新增 server 不需要过多的配置。比较麻烦的是新增的 server 需要配置 db，有时候碰到网络不好的情况 bundler 还要花掉不少的时间。另外就是 passenger、nginx、log rotate 这些东西配置尽管不是太复杂，但非常繁琐。&lt;/p&gt;

&lt;p&gt;中国的网络问题是部署时非常大的一个问题，下载一些第三方依赖的 library 会花掉不少时间。甚至有时干脆访问不了一些服务镜像，甚至大部分 setup 浪费掉的时间都与网络有关。我想过 docker 可以很好的解决我以上碰到的一些问题。也花了一些时间去研究，但 docker 镜像在中国的下载速度让我非常失望。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>找室友经历</title>
      <link>http://www.leyafo.com/post/2016-07-25-rent-room-story/</link>
      <pubDate>Mon, 25 Jul 2016 21:15:22 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2016-07-25-rent-room-story/</guid>
      <description>&lt;p&gt;这段时间一起住的室友离开上海搬走了。我现在住的地方（长宁区）房价比较高，对于我现在一个人承担所有房租压力还是不小的。由此我开始了长达将近一个月的时间找室友经历。不得不说这真的是一件非常麻烦的事情。但这一次经历让我这个长期和机器打交道的人觉得整个过程中还是有挺多有意思的事情，看到了以前自己没有看到的东西，也在其中学会不少。不得不说我现在和人打交道还是不太擅长，尤其是形形色色各种各样的人。&lt;/p&gt;

&lt;p&gt;最开始我抱着找个靠谱的室友，尽量少点麻烦，少点事情的想法去找室友。把原本在市场价的房子抬高了 20%，然后打算等人过来看房再把价格恢复，这样就能少一点人来看房，能尽量筛选出靠谱的室友。经历过一周无人问津，我才发现这是一个愚蠢的做法，我完全低估了租房市场对价格的调节作用。租房的价格真的不是随随便便找个对价格不敏感的人随便涨上来的。在这个市场，价格几乎是透明的，一旦当前的价格高于房子的质量，马上这个房子就会无人问津。这个市场里面实际上每一个人都是对价格很敏感的。因为它不是一次性交易，它会影响租房者以后每一个月的生活质量。这是我用实际行动得到的证明。&lt;/p&gt;

&lt;p&gt;目前看来没有一个平台完全把合租找室友这个问题给解决好了的。我在 &lt;em&gt;58，赶集，搜房，百姓，豆瓣，&lt;/em&gt; *smartshanghai*，这些几乎能想到的平台全部都发了贴。最后结果证明豆瓣发帖找室友的的转换率是最高的。来看房的人几乎 90% 都是来自豆瓣。其他平台有过一些过来联系的，但不多，全部加来我都要计算下能不能得到余下的 10%。至于其中租房者的素质在都差不太多，没有太大的差别。&lt;/p&gt;

&lt;p&gt;从外面找室友这事现在在我看来算是社交活动。两方是报着想尽快解决这个问题（找室友）的想法来见面的。我在这里面实际上扮演的是一个二房东角色，但一开始我完全没有意识到这一点。这里面两方都是很焦虑的人，我作为房主（二房东）想着的是尽快找个合适的人过来住，不然多拖一天我会要多付一天的房租。而过来看房的人想着的是尽快找个房间住下来，不然没地方住是件非常麻烦的事情。两方的差别在于我（二房东）现在有房住的，而租客将要面临的是没地方住的问题，这就是两方细微的差异所在。这就导致了我在网上发的贴大多数人首先想要了解的是房子是什么样的，而跟本不关心合租的人是什么样的。而我首先想要了解的是过来的这个人怎么样，靠不靠谱，以后住在一起会不会出现生活上的矛盾。这就导致我和很多看房的人在一开始沟通就不欢而散。大多数人并不想告诉我他／她现在的真实状况，有的人加微信时直接对我屏蔽朋友圈。甚至有得人都说不清楚他现在具体的工作内容是干什么的，这就是我这段时间恼火的根源之处。后来我发现在网上未见面的情况下沟通不畅，即使抱着见一面会更好的心态去见个面沟通还是会不畅，甚至交流之后对这个人的坏印象会更加厉害。在与人沟通时情绪控制是很重要的，短时间内和不同的人沟通很难不把对上一个人的情绪带到下一个人身上。最好是不要有什么主观上的情绪，不然别人是很容易感知到你的情绪，会对整个沟通过程产生很大的影响。&lt;/p&gt;

&lt;p&gt;在找室友的这段时间，我看到了一些租房市场的情况。我在豆瓣上发的贴来问的 90% 全部都是应届毕业生。这些应届毕业生大多数都要如下特点：收入低、工作不稳定、爱砍价。这与我预想中的情况完全不一样。我预想的是我按市场价出租，希望对方也市场的规矩来。如果对方砍点价下去，我就要为对房弥补掉这些便宜。去豆瓣找房的一般都是想把中介费省掉，更麻烦的地方在于这些去豆瓣找房的人心里老是打着能租到比市场价低的房子的想法。整个过程中与大多数人沟通都是不欢而散的，两方了解到的信息完全不在一个层面。更残酷的事实是应届毕业生想要租到靠近市区的地方必须要花掉他们几乎一半的收入来租房。刨去生活上的费用，他们几乎所剩无几，可能每月还要面临负收入，这是让人很难接受的，尤其是家庭经济条件不好的同学。所以他们讨价还价这个行为的真相是他们真的无法负担这里的房租。&lt;/p&gt;

&lt;p&gt;我的好朋友说，好的产品就是解决人的焦虑。这句话在这里真的很适合。租房网站从来就没有解决好这个问题，这也是为什么现在信息这么发达了，中介仍然存在。因为这个市场真的需要这样的人。房屋中介和租房的人实际上打交道的次数只有那么一次，不用以后和租房者打交道。所以它们不会有与不靠谱人员见面打交道的负担，让他们专门负责筛选需要租房的人是再合适不过了。因为他们把长期的一个交易变成了他们的一次性交易。&lt;/p&gt;

&lt;p&gt;一些有趣的发现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;联系方式越容易获取，随便看看想碰运气的人就越多。&lt;/li&gt;
&lt;li&gt;大部人都不太会仔细看帖，只会仔细找联系方式。&lt;/li&gt;
&lt;li&gt;我把租房贴改成全英文后，来联系的全部是女生，没有一个男生。&lt;/li&gt;
&lt;li&gt;现在应届毕业生的工资挺低的，相对于我以前的租房价格。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>开发笔记(1) － Count 问题 </title>
      <link>http://www.leyafo.com/post/2016-07-13-development-notes-1-count-problems/</link>
      <pubDate>Wed, 13 Jul 2016 02:51:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2016-07-13-development-notes-1-count-problems/</guid>
      <description>&lt;p&gt;我们现在的生产环境里面最大的表数据量大概是 1kw 左右。我们这里有一个页面是将这张表里面的数据以列表的方式呈现出来。这个列表的功能有：上一页/下一页、跳页、总数页、数据的总条目数。这是一个很常见的 web 列表拥有的功能，这一系列的功能在数据量 10w 以下工作得很好。超过 10w 后页面 load 就会变得很慢。慢的主要原因是每次刷新操作和跳页操作都会去 Count 整个表，而且是精确的 Count，算法的复杂度为 O(n)。这种方式对于经常需要使用列表页查看数据的用户是完全不可接受的。&lt;/p&gt;

&lt;p&gt;我们开始着手优化这个问题。羊毛出在羊身上，我们用的是 Postgresql 的数据库，当然会想到使用 Postgres 的一些功能去做这个事情。很快我们在 Google 搜索到了 Postgresql 的 &lt;a href=&#34;https://wiki.postgresql.org/wiki/Count_estimate&#34;&gt;Count estimate&lt;/a&gt; 机制。它通过获取 pg_class 这张元表纪录的信息来得到一个表里面大致的数据量。这种方法非常快，速度可达到毫秒级。但它有以下缺点：1.无法精确统计（从 estimate 这个词的意思就能看出来） 2.只能获取整张表的大致数量，无法做 where 条件过滤。问题到这里似乎还是没有解决。&lt;/p&gt;

&lt;p&gt;从程序开发的角度来看，这个问题最好的解决方式是使用一个变量用来保存表的 Count，每次插入删除时需要对这个 Count 变量进行 +1/-1 操作。这样每次需要获取的 Count 时算法复杂度就会降到 O(1)，但从整体上看这个问题其实根本没有得到解决。数据库里面一张大表在做 Insert/Remove 时本身已经很慢了，维护这个 Count 变量需要保证原子操作。这么做不仅非常麻烦，还会增加 Insert/Remove 的开销。&lt;a href=&#34;http://www.varlena.com/GeneralBits/120.php&#34;&gt;这里是具体的做法&lt;/a&gt;。事情到这里已经很明显了，对于数据库精确的 Count，我们是没有办法开发出一种低于 O(n) 复杂度的算法。但这个问题真的无解了吗？&lt;/p&gt;

&lt;p&gt;现在的问题焦点全部都集中在 Count 上面，这个问题看起来是只要 Count 的性能快了，就能解决这个问题。但上面已经说，我们是无法开发出低于 O(n) 复杂度的 Count 算法。1kw 的数据量 O(n) 是无论如何也快不到哪里去的。跳出这个点来看，我们最终要解决的问题是什么？这个 count 的精确数字对用户来说真的能重要到牺牲等待时间来获取吗？其实在这个功能里面我们只所以需要 Count 这个数字仅仅是在做分页时精确需要计算出有多少页，尾页的数字是多少。所以影响这个问题的关键根本不是用户的需求，而是我们在程序开发时所追求的精确。只需要把这个 count 数字去掉就可以了，这将会让列表的操作速度大大的提升。实际上搜索引擎就是这么干的。以 Google 搜索为例，我们在搜索引擎随便输入点东西进行搜索得到得结果是海量的，它只会告诉你“大约”得到多少个结果，结果页展示一页，你并不会知道尾页在哪里（也不需要知道）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于测试</title>
      <link>http://www.leyafo.com/post/2016-05-16-about-test/</link>
      <pubDate>Mon, 16 May 2016 00:25:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2016-05-16-about-test/</guid>
      <description>&lt;p&gt;在我做 C/C++ 开发时测试这个概念在这个圈子里不那么流行，这也有可能是 C/C++ 这类静态语言写 test 不是那么好写。 C/C++ 这类静态语言写 test code 光想一想也挺烦的。但这并不是因此就不写测试一个借口。我现在做的 Rails 项目一开始也认为写测试会拖慢项目进度的，后来实践下来发现测试能很好的维护项目的稳定，这实际上节约了不少时间。只要克服下一开始认为测试代码会增加的心智负担就好了。&lt;/p&gt;

&lt;p&gt;我们也不必太需要去理会什么 TDD，BDD，DDD 等一类名词。这一类名词对写测试的帮助并不大，而且有害。把原来本来很简单的事情弄得很复杂。写测试关键是要简单，只有简单的测试代码才能测试简单的测试代码。恩，这个有点绕。意思就是代码必须要容易测试，不容易测试的代码要把它改成容易测试的代码。TDD 奉行的测试驱动开发在我看来是挺难做到的。因为有时候我自己都不知道这个代码写好后会变成什么样子。单纯的一个输入输出是很难决定代码中间所经历的一些过程。还有一个重要的点就是被测试代码粒度越小越好，越小意味着模块化程度越高，接口的定义也越干净，这是非常值得的。所以别管什么 BDD, TDD, DDD 这一类名词，尽管写测试代码好了，尽可能把测试覆盖面辐射到更广才是最重要的。&lt;/p&gt;

&lt;p&gt;Rspec 的问题
Rspec 定义了测试的领域语言，他的目的是让非开发人员也能写测试。这个目的挺美好的，想想也挺美好的。实际上我们在项目中很难找到一个会去写测试的测试工程师。写 Rspec 这个东西没有一点开发能力还真搞不定。所以 Rspec 的让非开发人员写 test code 还是想想就好了，test code 还是得你自己来写，因为你对你自己写得模块是最清楚的。另外相对于 Rails 自带的测试框架 Rspec 解决的还是相同的问题。Rails 自带的测试框架已经挺好的了，模块化分析测试也很好的控制了测试的粒度。关键是它非常快，跑完所有的测试要同样数量的 Rspec 快很多。这很重要，Rspec 的性能很为人诟病，因为会增加对写 test code 的厌恶。一个简单的测试用例要跑 10 秒是很影响写代码的体验的。&lt;/p&gt;

&lt;p&gt;测试的作用
改代码比写新的代码要烦，需要小心的应对以前的历史包袱，还要了解以前的工作机制是怎样的。所以，如果有一些现成的测试用例代码就能很好的应对这些问题。它能保证你不回对以前的代码产生副作用，并且在些测试代码阶段可以让你自己在代码层面对接口的合理性做更详细的检查。能让代码质量变得更高。在项目部署前跑一遍所有的测试用例可安心不少，尽管部署时出现的问题大多数集中在恶劣的服务器环境上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>彻底理解 KMP算法</title>
      <link>http://www.leyafo.com/post/2014-11-14-a-thorough-understanding-of-kmp/</link>
      <pubDate>Fri, 14 Nov 2014 07:02:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-11-14-a-thorough-understanding-of-kmp/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm&#34;&gt;KMP&lt;/a&gt; 算法是一种子串匹配算法。其特点在于匹配子串时&lt;strong&gt;利用已经匹配成功的部分子串来跳转到下一次能再次匹配的串&lt;/strong&gt;。书上列举的一大堆公式看着很犯晕，网上各类码农博客里面用代码写的文章，让本来逻辑有点绕的 kmp 更加绕。就我最近看到的文章来说最清晰的就是&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&#34;&gt;阮一峰&lt;/a&gt; 和 &lt;a href=&#34;http://www.cnblogs.com/yjiyjige/p/3263858.html&#34;&gt;详解KMP算法&lt;/a&gt;。这两辆篇文章解释的通俗易懂，也有一些不太明晰的地方。本文的目的是在于解释笔者本人在理解 kmp，及阅读这些资料时不明白的地方。
首先还是来看 kmp 匹配子串所使用的方法，下文中字符串“TEST ABCABCABCDEF” 表示要匹配的主串，字符串 &amp;ldquo;ABCABCDEF&amp;rdquo; 表示待匹配的子串。(用肉眼我们可以看到要匹配的子串的位置在最后的位置)。首先像暴力匹配一样我们把不匹配的字符串全部进行匹配并跳过。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;   TEST ABCABCABCDEF
     ABCABCDEF
   |
   |-------- 进入下一个位置进行匹配 ------&amp;gt;  TEST ABCABCABCDEF
                                          ABCABCDEF
                                          |
          &amp;lt;----- 还是不匹配,继续往前走 ------|
          |
          |
          ......前面三个还是不匹配.....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候我们待匹配的子串走到了‘TEST ’后面一个位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;         TEST ABCABCABCDEF
              ABCABCDEF
                    |
                    |------ D 和 A 不匹配。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候主串和子串出现了部分匹配的情况，这个时候我们的子串该如何前进继续匹配？目前能想到的方法就是按照暴力匹配的方式继续向前进一步。但本文的目的不在于讨论暴力匹配，所以这种方法被 Pass 掉。如果直接将子串移动到现在不匹配 D 的位置，这种方式会错过&lt;strong&gt;可能会匹配的子串&lt;/strong&gt;。比如下面这种情况会错过&lt;strong&gt;可能会匹配的子串&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;       ABCABCDEFGHIJK        -----&amp;gt;     ABCABCDEFG
       ABCDEFG                                ABCDEFG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此上面的移动是不合法的，算法会出现错误。从这里我们可以观察到合法的移动是将子串移动到 ABC 。这样我们就能再次匹配到 ABC，这也就是本文前面说的那句话，&lt;strong&gt;利用已经匹配成功的部分子串来跳转到下一次能再次匹配的串&lt;/strong&gt;。现在问题是我们该如何在程序中得到这个正确的移动位置？首先我们先来观察已经匹配的部分匹配子串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;         TEST ABCABCABCDEF 
              ABCABCDEF
                    |
                    |---------&amp;gt;部分匹配子串 ABCABC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里我们可以看到 ABC 出现了两次，因此 ABC 是我们需要的&lt;strong&gt;再次匹配的串&lt;/strong&gt;。但这个 ABC 是如何得到的？因此我们现在我们需要解决的问题有2个。
1. 找到&lt;strong&gt;再次匹配串&lt;/strong&gt;。
2. 确定这个&lt;strong&gt;再次匹配串&lt;/strong&gt;需要移动的位置。&lt;/p&gt;

&lt;p&gt;这个时候我们要解决的问题跟主串已经没啥关系了，我们的问题变成了找子串中&lt;strong&gt;重合&lt;/strong&gt;的子串。实际上还是找子串，不同的是这次我需要去&lt;strong&gt;分析部分匹配串里面的子串&lt;/strong&gt;。这个问题比较好解决，我们只需要把&lt;strong&gt;部分匹配串&lt;/strong&gt;全部分解为子串。就能找到出现两次或者两次以上的子串了。因此&lt;em&gt;ABCABC&lt;/em&gt; 可以分解为如下子串：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;BCABC
CABC
ABC
BC
C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是从后面开始分解的子串，这并没有归纳出所有的子串，还需要从前面开始分解。所以还可以从前面分解如下子串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ABCAB
ABCA
ABC
AB
A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&#34;&gt;阮一峰&lt;/a&gt;的 blog 中所说的前缀和后缀。引入前缀和后缀的目的是为了找到出现两次以上的子串。现在我们的第一个问题 &lt;strong&gt;找到再次匹配的串&lt;/strong&gt;已经解决了，相匹配的子串是‘ABC’。接下来解决第二个问题&lt;strong&gt;确定再次匹配串需要移动的位置&lt;/strong&gt;。这个问题看起来有点难，我们可以引入一些已知的条件来得到这个问题的解。&lt;br /&gt;
已知条件：
1.部分匹配串的长度
2.出现两次以上子串长度
从上面的前缀和后缀我们可以知道，只需要把相同后缀移动到最前面就能和前缀匹配。因此可以得到下面的公式：
要移动的位置 = 部分匹配的长度 - 出现2次以上的后缀长度。
因此我们最后的结果要移动的结果为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;         TEST ABCABCABCDEF 
                 ABCABCDEF
                       |
                       |---------&amp;gt;移动位 6 - len(&#39;abc&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kmp 会把这些部分匹配的子串信息存到一个 next 数组里面。&lt;em&gt;ABCABCDEF&lt;/em&gt; 对应的 next 的数组如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;
                   ABCABCDEF
index         ---&amp;gt; 012345678
next          ---&amp;gt; 000123000
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>理解红黑树</title>
      <link>http://www.leyafo.com/post/2014-10-27-a-red-black-tree-implementation/</link>
      <pubDate>Mon, 27 Oct 2014 11:27:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-10-27-a-red-black-tree-implementation/</guid>
      <description>

&lt;p&gt;红黑树是有序平衡 BST(binary search tree) 的一种，它于1978年由 Guibas 和 Sedgewick 发明。红黑树是&lt;a href=&#34;http://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree&#34;&gt;2-3-4 树&lt;/a&gt; 的一种抽象表示。有趣的是现在大多数算法书关于红黑树都没有提到过 2-3-4 树。算法书上关于红黑树的讲解都是基于定理来实现红黑树。至于这些定理怎么来的，算法书却没有描述过。这就是为啥算法书上的红黑树难以理解，这是算法书的坑。所以要理解红黑树，理解 2-3-4树 是必不可少的一个过程。&lt;/p&gt;

&lt;h2 id=&#34;2-3-4树&#34;&gt;2-3-4树&lt;/h2&gt;

&lt;h3 id=&#34;2-3-4树的基本性质&#34;&gt;2-3-4树的基本性质&lt;/h3&gt;

&lt;p&gt;2-3-4树也是一种有序的平衡树，所有从 leaf 到 root 的 path 的高度都是相等的。每个节点可以容纳1到3个节点，可以有2到4个子节点。下面就是 2-3-4 树的3种类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;         B               D   F                H   K   O  
        / \             /  |  \              / \ / \ / \  
       A   C           B   E   G            A   I   L   Y  
        2树                3树                    4树
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于 BST，2-3-4对元素的排序是左小右大。不同的3树和4树的子节点会有中间大小的子节点。比如上图的3树中的 E 就比 D 大 比 F 小。4树中的 I 比 H 大，比 K 小。L 比 K 大，比 O 小。&lt;/p&gt;

&lt;h3 id=&#34;2-3-4树的插入&#34;&gt;2-3-4树的插入&lt;/h3&gt;

&lt;p&gt;前面说了 2-3-4树是一种平横树，所有从 leaf 到 root 的 path 的高度都是相等的。这也就意味着每当插入一个新节点不能单纯的像 BST 那样将新的节点插入到树的底部，否则会破坏树的平衡。2-3-4树使用的平衡方法是合并。就是将2树变为3树，3树变4树。如下图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;          B                         B
         / \        插入 D =&amp;gt;       / \
        A   C                     A  C D  
                                      
         B                            B
        / \          插入 H=&amp;gt;        /   \
       A  C D                      A   C D H
       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的插入方法解决了往 2-3-4树 插入新节点而不破坏树的平衡的问题。但是如果要插入的节点已经是一个4树了，这种方法就不管用了，因为4树是没法变为5树的。可以将4树往上挪一个节点，并分裂出俩个2树的子节点。如果上面的父节点已经是4树了，则继续往上挪动。直到 root 节点，再需要分裂的话，这个时候可以将 root 节点也进行分裂。root 节点分裂后整颗树的高度会增加一层。如下图所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;        A                  A S                      A   E   S          
       / \     插入 S=&amp;gt;    / | \         =&amp;gt;插入 E   / \ / \ / \    =&amp;gt; 插入 R ----&amp;gt;
       
      先将 A E S 往上分裂  =&amp;gt;      E                                E
                                /  \          插入 R=&amp;gt;           /  \
                               A    S                          A   R S
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-4树的删除&#34;&gt;2-3-4树的删除&lt;/h3&gt;

&lt;p&gt;树结构的删除都很麻烦，2-3-4树 也不例外。2-3-4树 插入的时候需要保持树的平衡，删除的时候也需要保持树的平衡。如果需要降低树的高度从 root 合并来降低树的高度。2-3-4树 和 BST 一样会选择从 leaf 节点将 node 删除。如果找到的节点不是 leaf 节点会从当前节点的右边出发，找到最左边的 leaf 节点来替换，然后删除被替换后的 leaf 节点。如果 leaf 节点是3树或者或者4树，直接删除即可。如果是2树的话就不能直接删除，需要对其进行旋转操作，从临近的同一层节点挪个节点过来补上。如果临近元素也是2树则从父节点挪一个节点下来。
下图是删除3树和4树的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;            C                   C                    D                  D
           /     删除 B=&amp;gt;       /                    /       删除 B =&amp;gt;   /
          AB                  A                    ABC                 AC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图是一个比较复杂的删除操作，删除一个非叶子节点，会碰到2树的删除并需要旋转的情况。(节点比较多所以用数字来表示节点)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;                  40
             /         \
           20           50                     删除根节点40
          /  \       /     \                   找到右树最左边的42节点 -----------&amp;gt;
        14   32     43     62 70 79            并替换掉,再删除替换后的叶子节点
        /\   /\     /\     / |  | \
      10 18 25 33  42 47  57 65 74 81
      
                    42
               /         \                       
            左树不变        50                    
                         /    \                  相邻节点也是2树，将43挪下来并合并 ------&amp;gt;
                      43     62 70 79            
                     / \     / |  | \             
                    x  47   57 65 74 81
                    
                    
                    42
                 /      \
             左树不变      50
                        /    \ 
                     43 47  62 70 79           上一步中43也是2树
                            / |  | \           需要从临近的节点通过旋转来拿到一个节点  -----&amp;gt;
                          57 65  74 81
                          
        
                        42
                     /      \
                 左树不变      62             &amp;lt;----- 62旋转上来
                            /    \ 
                          50     70 79
                        /   \    / |  \
                     43 47  57  65 74 81      &amp;lt;----------- 57变为50的子节点
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;红黑树&#34;&gt;红黑树&lt;/h2&gt;

&lt;p&gt;红黑树是2-3-4树的一种抽象表示，在1978年 Guibas 和 Sedgewick 发明最初的红黑树。2008年 Sedgewick 对其进行了改进，并将此命名为 LLRBT(Left-leaning red–black tree 左倾红黑树)。LLRBT 相比1978年的红黑树要简单很多，实现的代码量也少很多。Sedgewick的一篇 &lt;a href=&#34;http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf&#34;&gt;PPT&lt;/a&gt; 对此有非常详细的介绍。 现在大部分工程中的红黑树都是基于1978发明的算法，本文介绍的是 LLRBT。&lt;/p&gt;

&lt;h3 id=&#34;红黑树的抽象表示&#34;&gt;红黑树的抽象表示&lt;/h3&gt;

&lt;p&gt;在红黑树中表示2-3-4树的3树和4树会用红链接来表示。如下图所示(markdown 没有文本色彩支持，本文用//或\\来表示红色链接)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;      A B                   B             A             A B C                     B
     / | \  &amp;lt;=红黑树表示=&amp;gt;  //    或者 =&amp;gt;    \\          / | | \    &amp;lt;=红黑树表示=&amp;gt;  //  \\
                         A                  B                                  A      C
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;红黑树的插入&#34;&gt;红黑树的插入&lt;/h3&gt;

&lt;p&gt;红黑树在插入时也通过旋转来降低或者升高树的高度(关于旋转请看我的&lt;a href=&#34;http://leyafo.logdown.com/posts/178297-avl-tree-implementation&#34;&gt;另一篇文章&lt;/a&gt;)。不同的是红黑树插入节点的方式是按照2-3-4树插入节点的方式来进行的。2-3-4树每插入一个节点会对树自底向上进行调整(合并或分裂)，红黑树也是对应于2-3-4树进行同样的操作。2-3-4树通过将3树合并为4树，4树分裂为俩个2树。红黑树通过旋转来做这些操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;   在2树中插入一个节点：
     D  插入C=&amp;gt;    D
                 //
                C                                                         
                                                   &amp;lt;===等同于3树===&amp;gt;    C D
                   C                       D                          / | \
     C 插入D=&amp;gt;       \\          左旋=&amp;gt;   //
                      D                C
                     
    
    在3树中插入一个节点:  
    
     C H                    H             H 
    / | \      红黑树表示=&amp;gt; //            //             C                         A C H
                         C   插入 A=&amp;gt;   C      右旋=&amp;gt;  // \\       2-3-4树表示=&amp;gt;   / | | \
                                      //             A    H
                                     A

                         H              H              H           
    A H     红黑树表示=&amp;gt; //             //             //             C                  A C H
   / | \              A    插入 C=&amp;gt;    A    左旋=&amp;gt;    A     右旋=&amp;gt;  // \\  2-3-4树表示=&amp;gt; / | | \
                                       \\          //            A    H              
                                         C        C          


    A C                    C             C
   / | \      红黑树表示=&amp;gt; //            // \\                                A C H
                        A   插入 H=&amp;gt;   A     H               2-3-4树表示=&amp;gt;   / | | \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上图可以看出，LLRBT 之所以使用左倾(left-leaning)是为了将3树限制为一种，以便更容易的将3树转为4树，来减少实现上复杂度。下图是4节点的分裂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;
                                                         /                  //
      A C H     4树分裂为俩个2树=&amp;gt;  C                      C                 C
     / | | \                     / \      红黑树表示=&amp;gt;  // \\      分裂=&amp;gt;   / \     &amp;lt;---将红链提上去
                                A   H                 A    H             A  H  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;红黑树在最初插入时使用的方式和普通的二叉树一样，递归查找到树的底部，然后将新节点插入到树的底部。在递归往回弹的时候对整颗树进行旋转调整，和2-3-4树使用相同的方式（3树变4树，4树分裂成俩个2树）来调整整颗树的高度。&lt;/p&gt;

&lt;h3 id=&#34;红黑树的删除&#34;&gt;红黑树的删除&lt;/h3&gt;

&lt;p&gt;红黑树的删除方法非常复杂。删除任意一个节点，红黑树会像 BST 一样会从右树的最左边找到一个节点进行替换并删除。所以实现红黑树的关键一点就是要实现 DeleteMin 方法。LLRBT  结构是没有 parent 节点的，在删除一个节点是并不能像 AVL 树那样在删除后再旋转。 LLRBT 在查找要删除的节点时就会对树进行调整，它会将要删除节点的那个方向的树通过旋转将树的高度升高一层。&lt;br /&gt;
下图是在 DeleteMin 方法中将树的左边升高一层&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;          //       &amp;lt;----因为树是向左边递归的，           /
         H              所以到 H 的链都是红的           H
        / \                                        // \\
       C   S          颜色反转，将红色向下传=&amp;gt;        C    S     
      /                                          /
     B                                          B

    这时如果 S 节点的left为红色，需要对其再做两次旋转
           /                          /                        /
          H                          H                        P
        // \\                      // \\                    // \\
       C    S       右旋S=&amp;gt;        C    P         左旋 H=&amp;gt;   H    S      
      /    //                    /      \\                //  
     B    P                     B         S              C
                                                        /
                                                       B
     
                                                      //
            再将颜色反转回来=&amp;gt;                          P
                                                    / \
                                                   H   S
                                                 //
                                                C
                                               /
                                              B                                               
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面做的这些操作的最终目的就是将树的最底部要删除的节点变为红色，这样是为了在删除的时候避免要删除的节点为2树。因为删除3树中的一个节点是不需要做其他转换可以直接删除的。在删除后需要重新自底向上修复整颗树的平衡。这样的删除方式看起来非常慢，实际上确实&lt;a href=&#34;http://www.read.seas.harvard.edu/~kohler/notes/llrb.html&#34;&gt;非常慢&lt;/a&gt;。即使在没有找到要删除的节点也会递归进行旋转-修复这一过程。另外这里的删除使用的抽象方式并不是2-3-4树的删除方式，实际上使用的是2-3树的抽象方式。在红树向下传递的过程中最终的叶子会是颗3树，而不会是4树。Sedgewick 的 PPT 里面并没有说到这个问题。他的&lt;a href=&#34;http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf&#34;&gt;另一篇论文&lt;/a&gt;才说到了这个问题。&lt;/p&gt;

&lt;p&gt;PS：
本人实现的 &lt;a href=&#34;https://github.com/leyafo/practice-algorithm/blob/master/DataStruct/rb_tree.c&#34;&gt;Red Black Tree&lt;/a&gt;。
Sedgewick 的 &lt;a href=&#34;http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf&#34;&gt;PPT&lt;/a&gt; 里面有两个错误.
    1. 在 deleteMax方法中向下递归是 deleteMax(h.left) 应该是 deleteMax(h.right)。
    2. 在 delete 方法中需要添加当前节点是否为空的判断，否则递归到空节点时程序会挂掉。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rails 注册登录</title>
      <link>http://www.leyafo.com/post/2014-07-24-rails-log/</link>
      <pubDate>Thu, 24 Jul 2014 08:53:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-07-24-rails-log/</guid>
      <description>

&lt;p&gt;这几天在做一个小型的论坛，做到了注册登录这一块。之前没有完整做过注册登录这个东西，这次我打算从头写到尾去详细的了解里面的一些基本原理。所以这次并没有使用&lt;a href=&#34;https://github.com/plataformatec/devise&#34;&gt;devise&lt;/a&gt;这样的 *gem*。&lt;/p&gt;

&lt;h2 id=&#34;密码存储&#34;&gt;密码存储&lt;/h2&gt;

&lt;p&gt;用户密码安全存储是作为一个 &lt;em&gt;web&lt;/em&gt; 开发者的基本节操。好在现有的一些解决方案已经能比较好的解决这个问题了，做起来也比较容易。只需要了解一些基本的安全常识就可以保证90%的情况下是安全的。
在数据库里面存储加密后的密文是为了防止被拖库，如果黑客拖下了整个用户表，加密后的密码他们拿着也是没有用的。即使是网站的管理员也是没法知道这个密码的真实原文。因为现在一般的密码 &lt;em&gt;hash&lt;/em&gt; 算法是不可逆的。所以现在的一些比较常用的密码明文获取方式是进行&lt;a href=&#34;http://blog.jobbole.com/61872/&#34;&gt;字典暴力破解&lt;/a&gt;。如果在密码原文 &lt;em&gt;hash&lt;/em&gt; 前给密码添加一些比较长的唯一的随机字符串，这会使攻击者的字典基本上失效(因为很长，枚举次数要上升很大一个数量级)。这就是密码加盐(salt)的基本作用。当然加盐的另外一个作用是让两个相同的密码产生不同的 &lt;em&gt;hash&lt;/em&gt; 值。这样即使知道加密算法和加密后的密文也无法通过比较密文来得到原文。
在用户登录时我们会拿到用户的原始密码，这个原始密码相当于一把&lt;strong&gt;钥匙&lt;/strong&gt;。拿着这个密码通过加密算法和数据库里面的 &lt;em&gt;salt&lt;/em&gt;  得到加密后的密文。再用这串密文与数据库的密文进行比对，比对成功后则验证通过。在这样一个过程中，密码看起来就像打开箱子的钥匙一样，由用户携带，网站不进行存储。&lt;/p&gt;

&lt;h2 id=&#34;session-和-cookie&#34;&gt;session 和 cookie&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;cookie&lt;/em&gt; 是存储在用户浏览器中的一段唯一标识，&lt;em&gt;http request&lt;/em&gt; 会将它传送到服务端。现在一般的 &lt;em&gt;web framework&lt;/em&gt; 会去检测用户的 &lt;em&gt;http request&lt;/em&gt; 是否带有 &lt;em&gt;cookie&lt;/em&gt;, 如果没有发现请求中没有 *cookie*，它会建立一个*session*。并且以 &lt;em&gt;cookie&lt;/em&gt; 作为 &lt;em&gt;key&lt;/em&gt; 来保存 *session*。这样如果用户下次同样 &lt;em&gt;cookie&lt;/em&gt; 的 &lt;em&gt;http request&lt;/em&gt; 进来了，就可以找到相同的 *session*。
&lt;em&gt;session&lt;/em&gt; 和 &lt;em&gt;cookie&lt;/em&gt; 是实现记住用户的基石。&lt;em&gt;http&lt;/em&gt; 协议是无状态的协议。在用户登录某一个网站后，我们是需要记住登录状态的。这时候就要通过 &lt;em&gt;cookie&lt;/em&gt; 和 &lt;em&gt;session&lt;/em&gt; 来干这件事情。 &lt;em&gt;rails&lt;/em&gt; 默认是已经将 &lt;em&gt;session&lt;/em&gt; 建立好了。在 &lt;em&gt;controller&lt;/em&gt; 中可以很方便的拿到 &lt;em&gt;session&lt;/em&gt; 变量去存储一些信息。另外比较有意思的是 &lt;em&gt;rails&lt;/em&gt; 默认是将 &lt;em&gt;session&lt;/em&gt; 经过加密后存储在用户 &lt;em&gt;cookie&lt;/em&gt; 中的。当用户的 &lt;em&gt;cookie&lt;/em&gt; 传送到后端时会将 &lt;em&gt;cookie&lt;/em&gt; 进行解密得到相应的 *session*。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Capistrano 部署</title>
      <link>http://www.leyafo.com/post/2014-06-19-capistrano-deployment/</link>
      <pubDate>Thu, 19 Jun 2014 03:07:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-06-19-capistrano-deployment/</guid>
      <description>

&lt;p&gt;这几天要部署自己做的一个小板凳，是用 sinatra 写的一个简单的 blog 程序。这个程序很简单，代码非常少，可以像 php 那样直接使用 async 将代码。但我想熟悉下 Ruby 关于部署方面的技术，因此找到了 Capistrano 这个东西。Rails 的 web 后台对环境非常挑剔，Capistrano 是 Ruby 写的， 虽然它可以部署各种语言的代码，但可以部署 Rails 的程序不会太简单。&lt;/p&gt;

&lt;h2 id=&#34;配置项含义&#34;&gt;配置项含义&lt;/h2&gt;

&lt;p&gt;Capistrano 这个东西产生的一大堆配置文件有点让人迷糊。Capfile 相当于一个 makefile 文件，里面设置了一些任务是如何运行的。config目录下有三个配置文件，其中 deploy 子目录是用于配置部署不同的环境。默认的是 production 和 staging 环境配置项分别对应两个同名的文件。deploy.rb 这个文件相当于一个总配置文件，里面的是一些公共的配置项。&lt;br /&gt;
  Capistrano 非常依赖版本控制，在 deploy.rb 文件中 repo_url 是用于设置代码仓库的地址的，配置好这个参数后需要确认服务器有访问代码仓库的权限。 scm 是设置具体的版本控制软件的。Capistrano 支持最好的是 git 和 svn。 deploy_to 是一个非常重要的参数，它指示了代码上传到服务器的具体位置,另外需要确保这个目录与配置好的用户名有足够的访问权限。这几个参数设置好后，其他的参数可以使用默认的了。然后再配置对应环境的具体配置项。
  在环境配置项中，role 参数指示的三项分别是 app，web 和 db。这个三项分开的好处是可以让他们部署到不同的服务器上做负载均衡。单台服务器不用太关心，三项指向同一个地址即可。然后配置服务器的访问权限，配置非常简单，设置好用户名和 ssh public key就可以了。到这里基本的配置已经完成了，运行cap deploy:check 可以检测配置是否成功。这个时候如果 check 成功的话使用 cap deploy 命令就可以成功上传代码了。&lt;/p&gt;

&lt;h2 id=&#34;让代码运行&#34;&gt;让代码运行&lt;/h2&gt;

&lt;p&gt;代码上传后部署的任务已经完成了一小部分了，接下来就是具体的程序的启动与 http request的转发了。我使用的是 nginx + unicorn 组合来干这件事情的。首先要确保代码在本地能正常的运行起来，然后再去服务器上做进一步的测试。实际上更好的方式是所有的软件在本地的机器上能完全正常运行后，再将同样的配置文件上传至服务器。能避免不少因为不同机器，不同环境而引起的问题。这样服务器只负责运行软件，不做任何测试。这也是我最近所理解的生产环境。
首先来配置 unicorn 这个东西，一般的 web framework 都会自带 http 服务器用来做测试。自带的 http 服务器是不推荐直接跑在生产环境下的。nginx 更适合干这种事情，但 nginx 干的事情更加单一，它只负责将请求接收并转发。并不负责应用层的事情。unicorn就是这个应用层（php对应的是fastcgi），他负责将代码运行起来并与nginx进行通信。unicorn配置起来也非常的简单，在config.ru中配置好程序的入口点和unicorn.rb中配置好程序的pid，sock 和 log 文件路径。其中 pid 文件是用于启动与停止后台运行的 unicorn。sock 文件用于和 nginx 进行通信。
现在可以配置 nginx 了，nginx 的配置非常简单。只要设置好 nginx 的 upstream 项，在此项里面设置好 unicorn sock 的具体路径，就可以顺利通过 nginx 访问到unicorn了。&lt;/p&gt;

&lt;h2 id=&#34;capistrano-的-task&#34;&gt;Capistrano 的 task&lt;/h2&gt;

&lt;p&gt;nginx 与 unicorn 部署好后，就可以借助 Capistrano 的 task 来进行一些必要的代码部署步奏。比如重启 http 服务器，更新数据库等一系列事情。这些事情使用 Capistrano 来完成的好处是，task写好好每次部署只需要一条命令就可以自动化完成一些繁琐的事情。这个才是 Capistrano 最核心要解决的问题。
这里拿 unicorn 的重启为例来展示如何在远端服务器执行一些 shell 命令。unicorn 网上有一个控制它停止与重新启动的 &lt;a href=&#34;https://www.google.com/search?q=unicorn&amp;amp;oq=unicorn&amp;amp;aqs=chrome..69i57j69i59l3j69i60l2.926j0j1&amp;amp;sourceid=chrome&amp;amp;es_sm=119&amp;amp;ie=UTF-8#newwindow=1&amp;amp;q=unicorn_init&amp;amp;safe=off&#34;&gt;shell&lt;/a&gt; 脚本。下面是一个 task 的具体代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;%w[start stop restart].each do |command|
  desc &amp;quot;#{command} unicorn server&amp;quot;
  task command do
    on roles(:app, :web) do
      execute &amp;quot;sh #{fetch(:current_path)}/config/unicorn_init.sh #{command}&amp;quot;
    end
  end
end
before :deploy, &amp;quot;unicorn:stop&amp;quot;
after  :deploy, &amp;quot;unicorn:start&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 on roles 指定的是要执行命令具体的服务器，exexcute 是执行具体命令的函数。其中(:current_path)指定的是当前release 代码的路径。因为每次使用 cap deploy 命令后，都会产生一个新的 release，然后远端会切换版本到新的 release 目录。before 和 after 是 hook，它指示了每次某一项任务开始前和完成后所做的一些工作。&lt;/p&gt;

&lt;h2 id=&#34;capistrano-2-与-capistrano-3&#34;&gt;Capistrano 2 与 Capistrano 3&lt;/h2&gt;

&lt;p&gt;Capistrano 2 与 Capistrano 3 差别非常大，一些配置项完全是需要重写的。现在从网上的资料和 github 的 issue 来看 2 比 3 要多很多。可参考的教程2比3也要多出很多，我在使用的是Capistrano 3，在部署时遇到不少的问题。因此如果没有太高的要求，建议继续使用2。以下是我在部署的过程中碰到的一些差异。&lt;/p&gt;

&lt;p&gt;Capistrano 2 可以使用 sudo 执行命令，Capistrano 3 却不行。据他们自己说是为了安全考量。
Capistrano 3 的 task 必须要指定具体的 roles。
Capistrano 2 可以直接调用 set 设置的属性，而 Capistrano 必须使用 fetch 函数去获取。
Capistrano 3 去掉了 current_path, shared_path 等一些公有变量，据说是为了防止部署失败而设计的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我认为PHP不好的地方</title>
      <link>http://www.leyafo.com/post/2014-05-22-i-think-php-is-terrible/</link>
      <pubDate>Thu, 22 May 2014 00:29:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-05-22-i-think-php-is-terrible/</guid>
      <description>

&lt;p&gt;最近在用PHP做项目，让我个人感觉PHP是门非常不顺手的编程语言。PHP太多东西给人的感觉就像是一个半成品。&lt;/p&gt;

&lt;h2 id=&#34;namespace&#34;&gt;namespace&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;PHP&lt;/em&gt; 的 &lt;strong&gt;namespace&lt;/strong&gt; 是我见过的所有语言最难用的 &lt;strong&gt;namespace&lt;/strong&gt;，没有之一。它使用反斜杠&lt;strong&gt;\**来进行层级切分，在使用上非常容易跟 &lt;em&gt;include&lt;/em&gt; 使用的文件路径斜杠搞混淆。&lt;/strong&gt;namespace** 的 &lt;strong&gt;use&lt;/strong&gt; 语句使用也是让人赶到非常奇怪，它不能在代码中的任意作用域使用，只能在一个文件的最顶级作用域中使用 &lt;strong&gt;use&lt;/strong&gt;。&lt;strong&gt;namespace&lt;/strong&gt; 这个东西是控制访问冲突使用的，在文件顶级作用域中使用 &lt;strong&gt;namespace&lt;/strong&gt; 是一个产生冲突的隐患。这就是一个半成品，&lt;em&gt;PHP&lt;/em&gt; 中的内部库函数是没有使用 &lt;em&gt;namespace&lt;/em&gt; 的，也不知道他们自己为啥不用这玩意。&lt;/p&gt;

&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;

&lt;p&gt;在每一个变量前加一个&lt;strong&gt;$&lt;/strong&gt;符号，让我对这个语言的第一印象非常不好，给我的感觉是丑陋。变量名加&lt;strong&gt;$&lt;/strong&gt;可以很方便的嵌入到字符串中，但是 &lt;em&gt;PHP&lt;/em&gt; 在字符串内嵌中增加了 &lt;strong&gt;{}&lt;/strong&gt; 语法，这让变量前面 &lt;strong&gt;$&lt;/strong&gt; 符号失去了它唯一的作用。&lt;strong&gt;$&lt;/strong&gt; 符号除了让代码变得更丑陋以外，没有任何的实际用处。另外在 &lt;em&gt;PHP&lt;/em&gt; 中 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;for&lt;/strong&gt; 还有 &lt;strong&gt;while&lt;/strong&gt; 一系列控制语句中，变量是没有作用域的。可以很随意的去拿 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;else&lt;/strong&gt; 中的变量，解释器不会报错。但是你不知道什么时候解释器会给你报一个 &lt;strong&gt;undefine&lt;/strong&gt; 的错误。&lt;/p&gt;

&lt;h2 id=&#34;函数与闭包&#34;&gt;函数与闭包&lt;/h2&gt;

&lt;p&gt;函数本身没啥好说的，每个语言最基本的单元。如果这玩意也实现不好那真的太糟了。但我要说的是 &lt;em&gt;PHP&lt;/em&gt; 从5.3以后引入的匿名函数。&lt;em&gt;PHP&lt;/em&gt; 的匿名函数看起来好像是可以在任意的地方定义它，这很符合匿名函数的特性。但问题是你如果要用到上下文变量需要显示的使用 &lt;em&gt;use&lt;/em&gt; 将变量引入。这看起来好像是没有什么问题，但是如果函数嵌套的层级一多，这完全是个枷锁。另外如果要判断一个变量是不是一个函数 &lt;em&gt;PHP&lt;/em&gt; 有一个 &lt;strong&gt;is_callable&lt;/strong&gt; 的方法,这个方法的奇怪之处在于你可以传入变量名或者以字符串形式传入函数名。但如果直接传入一个函数它返回的值是 &lt;strong&gt;false&lt;/strong&gt;。经过使用 &lt;strong&gt;is_callable&lt;/strong&gt; 函数的一些失败尝试后，我彻底放弃了 &lt;strong&gt;PHP&lt;/strong&gt; 的匿名函数与闭包。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>avl 树的实现</title>
      <link>http://www.leyafo.com/post/2014-02-09-avl-tree-implementation/</link>
      <pubDate>Sun, 09 Feb 2014 07:01:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-02-09-avl-tree-implementation/</guid>
      <description>&lt;p&gt;过年在家没事，找出了几年前把我折磨得死去活来的&lt;a href=&#34;http://book.douban.com/subject/1971825/&#34;&gt;&amp;lt;数据结构与算法分析&amp;gt;&lt;/a&gt;这本书。确切的说，这段时间这本书也在折磨我。上面的avl树的旋转说得不清不楚的，而且还是使用递归实现了avl树的插入与删除操作。让这本书上本身就已经不太清晰的描述变得更加的扑朔迷离，让我有一种想烧掉这本书的冲动。到最后我实在没法看懂书上描述的avl树的操作方式只好自己从网上找一些资料实现了avl树(&lt;a href=&#34;https://github.com/leyafo/practice-algorithm/blob/master/DataStruct/avl_tree.c&#34;&gt;代码在此&lt;/a&gt;)。另外&lt;a href=&#34;http://zh.wikipedia.org/wiki/AVL%E6%A0%91&#34;&gt;维基百科&lt;/a&gt;上有关于avl树基本性质的描述，我在这里也不过多介绍。但是请勿对照这篇文章去实现avl树，这篇描述的删除操作是有问题的。关于树的旋转，这篇文章也没有把最根本的问题说清楚。avl树最难的部分就是关于树的旋转，本文主要讨旋转的问题。&lt;/p&gt;

&lt;p&gt;首先，旋转的作用是降低子树的高度。旋转的方式有两种，一种是用来降低左子树高度一般被称作右旋。一种是用来降低右子树高度一般被称为左旋。这两种旋转在物理上是对称的，在编码上也是无脑对称的。因此，在编码方面我们只需要实现出一种旋转后另一种旋转也可以依葫芦画瓢的实现出来。另外在每个节点中保存一个父节点可以让编码的复杂度大大降低。&lt;/p&gt;

&lt;p&gt;下面是左旋的具体变化过程:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;      A                            B  
       \                          / \  
        B         左旋 ==&amp;gt;        A   C   
         \    
          C   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是右旋的具体变化过程:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;          A                      B   
         /                      / \    
        B         右旋 ==&amp;gt;      C   A    
       /                            
      C   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的这两种情况是比较理想的情况，在实际的使用情况下是没有这么理想的。不能处理下面这些情况。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;                 A                          A
                  \                        /
                   B                      B
                  /                        \
                 C                          C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的这两种情况就是书上所说的关于双旋转的问题。解决这两种情况的方法就是先旋转B节点,先将C点与B点旋转到A点与B点相同的指向方向。然后在根据A点做对应方向的旋转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;     A                A                C            A              A               C
      \                \              / \          /                \             / \
       B      =&amp;gt;        C       =&amp;gt;   A   B        B       =&amp;gt;         C      =&amp;gt;   A   B
      /                  \                         \                  \
     C                    B                         C                  B
     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写到这里貌似可以去开工写代码了，但是请等等。在实际的编码中碰到如下情况还是不知道到底该怎样旋转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;        A                                  A           
         \                                /
          B                              B
         / \                            / \
        C   D                          C   D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这两种情况中一般书上给的答案是‘判断新插入的节点到底是在左子树，还是在右子树’。然后再做对应的调整，这样确实是能解决问题的。但是在删除一个节点时，是不可能使用这种方法进行判断的。但我们可以根据树旋转的性质去解决这个问题。从上面的问题可以看出，树旋转最根本的原因就是降低树的高度。根据这个性质我们可以做进一步的分析。对不平衡的子节点去做旋转。那就是&amp;rdquo;哪边更高我们就去将它旋转一下，将它将降低一层&amp;rdquo;。 如果子节点两边的高度是一样的，或者更高的子节点方向与父节点一致的，那么就直接去旋转父节点。
   以上就是avl树基本的旋转过程，avl树和二叉树的插入与删除操作都是一样的。不同的是avl树在插入和删除后需要由下至上扫描并旋转整棵树以保持平衡。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我认为12306 可以改进的地方</title>
      <link>http://www.leyafo.com/post/2014-01-07-i-think-12306-areas-for-improvement/</link>
      <pubDate>Tue, 07 Jan 2014 10:10:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-01-07-i-think-12306-areas-for-improvement/</guid>
      <description>

&lt;h2 id=&#34;几条社会数据&#34;&gt;几条社会数据：&lt;/h2&gt;

&lt;p&gt;2013年春运期间卖出&lt;a href=&#34;http://www.sh.xinhuanet.com/2013-03/08/c_132218725.htm&#34;&gt;2.4亿&lt;/a&gt;张火车票，折半的话单趟就是1.2亿。
这1.2亿张火车票 &lt;a href=&#34;http://www.022net.com/2013/1-23/496633332230569.html&#34;&gt;网络售票数量不到4成&lt;/a&gt;
流动人口总数是2.2亿&lt;a href=&#34;http://money.163.com/11/0428/10/72NJ1E9I00253B0H.html&#34;&gt;(不包括市辖区内人户分离)&lt;/a&gt;。
12306日每天2000万人访问&lt;a href=&#34;http://www.ctocio.com.cn/cloud/120/12820120.shtml&#34;&gt;点击量&lt;/a&gt; 高达14亿
&lt;a href=&#34;http://s.weibo.com/weibo/12306%2520%25E6%259C%2580%25E9%25AB%2598%25E6%2597%25A5%25E5%2594%25AE%25E7%25A5%25A8?topnav=1&amp;amp;wvr=5&amp;amp;b=1&#34;&gt;最高日售票460万张&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上数据可以得出以下结论：
1.火车的运载量是不太够的。
2.实际网络买票人数员远大于12306售票数的总数。
3.12306卖出的票还是少了点。
下面是我认为12306可以改进的地方。&lt;br /&gt;
##网页前端可以改进的地方：
我这几天也经历过几次买票，在高峰期进入网站后基本上是一个卡住不动的状态了。经过仔细观察12306的前端我发现改进的余地还是非常大的。&lt;/p&gt;

&lt;h3 id=&#34;尽量静态化&#34;&gt;尽量静态化：&lt;/h3&gt;

&lt;p&gt;这么高访问量的网站必须要尽可能的减少客户端请求，网页前端能静态就静态。少设置一点图片，js与css可以参考rails的AssetsPipline 把所有的资源打包成一个文件，去掉不必要图片。这里可以参考&lt;a href=&#34;http://www.ruanyifeng.com/blog/2012/12/obama_fundraising_website.html&#34;&gt;奥巴马的选举网站&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;页面功能单一化&#34;&gt;页面功能单一化&lt;/h3&gt;

&lt;p&gt;访问量这么高，完全可以把网站所有不同功能的页面分开。订票与查询完全可以分开成两个页面，订票页面就不要再有其他的资源链接或者其它功能。&lt;/p&gt;

&lt;h3 id=&#34;订票过程尽量简单&#34;&gt;订票过程尽量简单&lt;/h3&gt;

&lt;p&gt;现在用户订票需要选择日期后再查询，然后服务器再返回好几趟车的数据。我认为这一步实在是很多余，买票的人这么多，大家都会事先查好需要买哪趟车，不会等到出票时间去查询再买。面对这种情况，最好是让用户直接再事前输入准确的车次，起终点站就可以了。这样就能减少服务器与客户端之间的数据传输次数与数据量。&lt;/p&gt;

&lt;h3 id=&#34;可增加的功能-没错-我认为应该增加一些功能&#34;&gt;可增加的功能（没错，我认为应该增加一些功能。）&lt;/h3&gt;

&lt;p&gt;现在的订票助手已经做到了离线化订票，既然这样12306为什么不直接把这件事给干了呢？12306拿到用户的订票信息，可根据偏远程度与火车的运载量在后台进行订票的优先级排序。甚至可以在某辆车运载量不够的情况下为用户自动安排最优化的换乘方案与对应的车票。&lt;/p&gt;

&lt;h3 id=&#34;增加电话订票的可用度&#34;&gt;增加电话订票的可用度&lt;/h3&gt;

&lt;p&gt;不得不说电话订票实在太难用了，中间经历的过程非常烦琐。能用电话订到票的基本上需要一部带有机械键盘的座机与职业游戏玩家的反应与手速才能做到。简化电话订票中间的流程，多开通几个订票号码，这样能分流一部分订票压力。&lt;/p&gt;

&lt;p&gt;##后台改进
从春运的卖出的2.4亿张火车票的数量上来看，这真的是实实在在的大数据处理。甚至被称为世界级难题我认为都是可以的。因为后台跟12306前端所面对的问题完全是不再一个层面上的。因为后台需要将电话，售票点，代售点，网络售票，退票这几个点的火车票全部进行管理。也就是需要为这2.4亿张火车票做一个中心数据库系统。而且这个系统需要满足：
&lt;strong&gt;高并发：&lt;/strong&gt;几百万人在一个时间点同时买票。
&lt;strong&gt;高可用性：&lt;/strong&gt;不能done机
&lt;strong&gt;高响应：&lt;/strong&gt;读写的时间不能太长
&lt;strong&gt;恐怖的一致性：&lt;/strong&gt;是的，这个一致性很恐怖。因为所有的订票请求，都需要在一个地方去拿，不能出现两个人订到了同一张票的情况。虽然电话，售票点，代售点，退票这几个点可以提前分配好资源。网络售票在一个时间点保持几百万个资源的一致性是非常恐怖的操作。&lt;/p&gt;

&lt;p&gt;###改进方案：
&lt;a href=&#34;http://coolshell.cn/articles/6470.html&#34;&gt;陈皓&lt;/a&gt;在去年提出了几点解决方案：&lt;strong&gt;数据镜像 ，数据分区 ，后端系统负载均衡&lt;/strong&gt;&lt;br /&gt;
他的大致思路是一个数据负载均衡的思路。就是尽量不让用户去大量的访问一个点。实际上铁道部已经在去年开始就使用了分时间段买票的方法。这一方法就是一个负载均衡的思路。效果是有了，但是实际上只是消化了一部分数据，但还是有海量的数据存在。我倒是比较赞同他的另外一个思路，就是收集用户的订单，然后到了一定的时间与数量再提交到中数据库中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我的思路：&lt;/strong&gt;
  既然要批量提交，为什么不把剩余票源提前从数据库里面挖出来做一个缓存，然后读写这块缓存，到最后在提交这块缓存到中心数据库。每个节点服务一批用户，缓存的节点不能太少，缓存应该在从中心数据里挖出来的那时候起就要保证将来数据库里一致性的问题。但难度在于如何将用户分配到适合的票源缓存点去？这就要按车次与席别还有乘车日期类型的不同来分配车票的类型。这个计算过程是独立，完全可以很轻松的做到并行计算。&lt;/p&gt;

&lt;p&gt;##小结
春运火车票这个问题基本上无解，因为 需要买票的人数 〉 票的总数。火车的载量也只有那么大，技术能解决的问题只能是让尽可能多人的人更顺利的买的票，不能产生更多的票。所以我想无论是叫阿里还是其他市场化的公司来做这个系统，没有买到票的人该骂的还是照样会骂。当然，上面的提出的一些方式也是比较理想化的。并没有过多的去考虑太多的细节问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails 的 AJAX</title>
      <link>http://www.leyafo.com/post/2014-01-06-rails-ajax/</link>
      <pubDate>Mon, 06 Jan 2014 14:00:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-01-06-rails-ajax/</guid>
      <description>&lt;p&gt;在 &lt;em&gt;Rails&lt;/em&gt; 中只需要指定在 &lt;em&gt;erb&lt;/em&gt; 模板中指定 &lt;em&gt;remote=true&lt;/em&gt; 选项就可以将请求变为异步的了。&lt;strong&gt;request-handle-response-callback&lt;/strong&gt; 这是一个 &lt;em&gt;AJAX&lt;/em&gt; 请求的过程。&lt;em&gt;rails&lt;/em&gt; 将这些步骤直接简化成了 &lt;em&gt;request&lt;/em&gt; 和 &lt;em&gt;handle&lt;/em&gt; 两步，让它看起来的像魔法一样而简洁神秘。在我初次接触 &lt;em&gt;Rails&lt;/em&gt; 的 &lt;em&gt;AJAX&lt;/em&gt; 时，我也随手去翻了下 &lt;em&gt;wikipedia&lt;/em&gt; 关于 &lt;em&gt;AJAX&lt;/em&gt; 的条目。&lt;em&gt;AJAX&lt;/em&gt; 很好理解，但这并未让我更好的去完全理解 &lt;em&gt;Rails&lt;/em&gt; 魔法般的 *AJAX*。主要被困惑的在 &lt;em&gt;controller&lt;/em&gt; 的 &lt;em&gt;handle&lt;/em&gt; 函数里面的 &lt;em&gt;response&lt;/em&gt; 实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;        def handle
        @model = new some_model
              
        #do something
        
                if @model.save
            respond_to do |format|
                format.js
            end
        end  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是一个典型的 &lt;em&gt;Rails&lt;/em&gt; 应用场景，完全没有了那些简单粗暴原生的 &lt;em&gt;html&lt;/em&gt; 与 &lt;em&gt;javascript&lt;/em&gt; 的代码，更加别想看到 &lt;strong&gt;XMLHttpRequest&lt;/strong&gt; 这种对象了。&lt;em&gt;respond_to&lt;/em&gt; 是一个接收代码块的方法。而 &lt;em&gt;format&lt;/em&gt; 表示 &lt;em&gt;response&lt;/em&gt; 时使用的数据格式，&lt;em&gt;format.js&lt;/em&gt; 会找到对应的 &lt;em&gt;handle.js&lt;/em&gt; 并将里面的 &lt;em&gt;js&lt;/em&gt; 代码 &lt;em&gt;repond&lt;/em&gt; 到客户端。这仅仅只是客户端需要 &lt;em&gt;js&lt;/em&gt; 类型回复的一个需求。如果客户端需要 &lt;em&gt;json，XML，HTML&lt;/em&gt; 等不同类型的数据，只需要在 &lt;em&gt;repondto&lt;/em&gt; 这个代码块使用 &lt;em&gt;format&lt;/em&gt; 对象调用对应的方法即可。&lt;em&gt;rails&lt;/em&gt; 会自动判断并回应对应的类型的数据到前台页面。
  这样做的好处有：
  1.&lt;em&gt;DRY&lt;/em&gt; 原则，不需要根据不同请求类型去定义对应的 &lt;em&gt;response&lt;/em&gt; 方法。
  2.避免因为 &lt;em&gt;request&lt;/em&gt; 与 &lt;em&gt;response&lt;/em&gt; 的数据类型不同而产生错误。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vim 最佳实践</title>
      <link>http://www.leyafo.com/post/2013-11-26-the-best-practical-vim/</link>
      <pubDate>Tue, 26 Nov 2013 04:01:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2013-11-26-the-best-practical-vim/</guid>
      <description>&lt;p&gt;#重装你的vim
是的,重新安装你的 &lt;em&gt;vim&lt;/em&gt;. 因为默认安装的 &lt;em&gt;vim&lt;/em&gt; 是不带 &lt;em&gt;python&lt;/em&gt; 和 &lt;em&gt;lua,ruby,perl&lt;/em&gt; 这一系列脚本支持的.因此你需要加入这些脚本支持,然后重新编译安装.重新安装前请先备份好 &lt;em&gt;~/.vim&lt;/em&gt; 目录中的东西与 &lt;em&gt;vimrc&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;##源码编译安装:
以 &lt;em&gt;OSX&lt;/em&gt; 系统为例,在 &lt;em&gt;vim&lt;/em&gt; 源码目录的 &lt;em&gt;src&lt;/em&gt; 目录下有一个 &lt;em&gt;configure&lt;/em&gt; 文件.运行 &lt;em&gt;./configure &amp;ndash;help&lt;/em&gt; 可以看到一些编译选项,从中添加你想要的编译选项.在添加 &lt;em&gt;&amp;ndash;enable-pythoninterp&lt;/em&gt; 请一定要带上 &lt;em&gt;&amp;ndash;with-python-config-dir&lt;/em&gt; 这个选项,用来指向你的 &lt;em&gt;python config&lt;/em&gt; 目录.在 &lt;em&gt;OSX&lt;/em&gt; 系统中这个值一般是: &lt;em&gt;/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config&lt;/em&gt;. 另外请勿使用 &lt;em&gt;homebrew&lt;/em&gt; 安装的 &lt;em&gt;python&lt;/em&gt;, 编译过程中会找不到 &lt;em&gt;python frameworks&lt;/em&gt;. 如果配置有问题可以查看 &lt;em&gt;src&lt;/em&gt; 目录中 &lt;em&gt;auto/config.log&lt;/em&gt; 来看详细错误.编译成功后会在 &lt;em&gt;src/macvim/build/release&lt;/em&gt; 目录生成好 &lt;em&gt;dmg&lt;/em&gt; 安装包.&lt;/p&gt;

&lt;p&gt;##从homebrew中安装:
&lt;em&gt;homebrew&lt;/em&gt; 也是下载好源码然后编译安装的.在 &lt;em&gt;brew install macvim&lt;/em&gt; 前,可以使用 &lt;em&gt;brew edit macvim&lt;/em&gt; 来编辑一些编译选项.只需要在 &lt;em&gt;args = %w[]&lt;/em&gt; 这个中括号里面添加 &lt;em&gt;configure&lt;/em&gt; 中的编译选项. 编译中产生的错误日志可以在 &lt;em&gt;~/Library/Logs/Homebrew/macvim&lt;/em&gt; 目录下查看.&lt;/p&gt;

&lt;p&gt;##重新安装所有的插件
在没有包管理器之前 &lt;em&gt;vim&lt;/em&gt; 的插件是个很不科学的东西.一个插件每次都需要复制 &lt;em&gt;.vim&lt;/em&gt; 插件文件与 &lt;em&gt;doc&lt;/em&gt; 文件到特定的目录中.安装非常麻烦,容易出错.并且 &lt;em&gt;vim&lt;/em&gt; 内部并没有提供后续的插件升级机制.因此后续升级你得自己先去了解插件有没有升级,然后再重新复制文件进行插件安装.这完全是恶心人,因此,用这种方式安装的插件大部分人是不会想着去升级插件的.
还好有了 &lt;a href=&#34;https://github.com/gmarik/vundle&#34;&gt;Vundle&lt;/a&gt; 这么个东西.它是基于 &lt;em&gt;github repositories&lt;/em&gt; 来安装与更新插件的.只需要在 &lt;em&gt;vimrc&lt;/em&gt; 配置好 &lt;em&gt;Bundle&lt;/em&gt; 项就可以搞定插件的安装与更新了.但请注意好 &lt;em&gt;Bundle&lt;/em&gt; 的名字,错了的话就会找不到 &lt;em&gt;github repositories&lt;/em&gt; .另外&lt;a href=&#34;http://vim-scripts.org/vim/scripts.html&#34;&gt;这里&lt;/a&gt;可以搜索到 &lt;em&gt;vim&lt;/em&gt; 几乎所有的插件.
安装完后,将先前备份好的 &lt;em&gt;.vim&lt;/em&gt; 文件夹下的 &lt;em&gt;color&lt;/em&gt; 与 &lt;em&gt;syntax&lt;/em&gt; 复制到新的 &lt;em&gt;.vim&lt;/em&gt; 文件夹中去.因为这两个文件夹下的东西 &lt;em&gt;Bundle&lt;/em&gt; 并未做管理,也不需要管理.&lt;/p&gt;

&lt;p&gt;#你不应该使用的东西
##自动补全
相信我, &lt;em&gt;vim&lt;/em&gt; 只是一个编辑器,自动补全这个玩意很难做到 &lt;em&gt;IDE&lt;/em&gt; 的那种效果.没有自动补全最开始可能会不习惯,写代码速度会慢一点.但习惯了会有很多好处.首先,你的代码命令会非常的规范,不会出现单词与大小写错误的问题.其次不使用自动补全你会对代码理解更好,更深刻.当然,你若要写 &lt;em&gt;Objective-C&lt;/em&gt; 这种的代码,你还是乖乖的用上 &lt;em&gt;IDE&lt;/em&gt; 去自动补全吧.不然这是不人道的.&lt;/p&gt;

&lt;p&gt;##别试图将你的 vim 打造成IDE
网上有很多 &amp;ldquo;将你的 vim 打造成 IDE&amp;rdquo; 一类的文章,别去看这种文章并且跟着他们去安装一些不解决&amp;rsquo;你碰到的问题&amp;rsquo;的插件.既然你都使用编辑器了,就别试图将改装成那种 &lt;em&gt;IDE&lt;/em&gt; 的环境.编辑有编辑器的用法,用得好会比 &lt;em&gt;IDE&lt;/em&gt; 效率更高.&lt;/p&gt;

&lt;p&gt;##不要去使用别人的配置文件
网上有很多公开的 &lt;em&gt;vimrc&lt;/em&gt; 文件,有很多高手的配置文件确实是神乎奇技.但那是别人的配置,别人有别人习惯与癖好.配置文件这个东西还是按你自己个人化的习惯来比较好.尤其是一些配置文件里改了快捷键后,你很难一下子去找到并适应这个快捷键.
另外,也不要去盲目的使用别人推荐的插件.大部分插件是解决特定存在的问题而产生的.你如果安装好一个插件,这个插件你并没有经常拿它去解决&amp;rsquo;你碰到的问题&amp;rsquo;.这个插件迟早有一天会被你遗忘在角落里.而且一些你不经常使用的插件的命令选项会给你造成不必要的记忆负担.&lt;/p&gt;

&lt;p&gt;#一些你应该知道的高级tips
##tag 跳转与缓冲区跳转
&lt;em&gt;vim&lt;/em&gt; 默认是集成了 &lt;em&gt;ctags&lt;/em&gt; 的接口,使用 &lt;em&gt;ctags&lt;/em&gt; 产生 &lt;em&gt;tag&lt;/em&gt; 文件后. &lt;strong&gt;ctrl+[&lt;/strong&gt; 可跳转到函数的定义与声明.使用 &lt;strong&gt;ctrl+o&lt;/strong&gt; 可以跳回上一个缓冲区, &lt;strong&gt;ctrl+i&lt;/strong&gt; 可以跳到下一个缓冲区.这三个快捷键基本上可以满足你到处跳来跳去了.
&lt;!------ mark功能不能在文件之间跳转
##mark
上面的跳转实际上功能比较弱,属于盲跳. *vim* 自带的 *mark* 可以让你有目的性的跳转.在命令模式下,使用 **m**再加一个命名的字母标记就增加了一个类似书签的东西.添加好后,可以是用 **&#39;(单引号)**加上你个刚刚命令的标记就可以跳到指定的地方去了,并且这种跳转还可以跨文件的.比如:使用 **ma** 添加一个标记, 然后使用 **&#39;a** 就可以跳到刚才的那个标记.另外使用命令 **:marks** 可以看到你设置的标记.其中 *0~9* 是最近编辑的文件.
---&gt;
##register
&lt;em&gt;vim&lt;/em&gt; 的 &lt;em&gt;register&lt;/em&gt; 功能类似于 &lt;em&gt;mark&lt;/em&gt; 但他记录了你最近删除与复制的文字.你可以将一段文字复制到特定 &lt;em&gt;register&lt;/em&gt; 中去.然后再从 &lt;em&gt;register&lt;/em&gt; 中复制出来.
使用 &lt;em&gt;visual&lt;/em&gt; 模式选择好一段文字,在命令模式下使用 &lt;strong&gt;&amp;ldquo;ay&lt;/strong&gt; 便将这段文字复制到了名字为 &lt;strong&gt;a&lt;/strong&gt; 的 &lt;em&gt;register&lt;/em&gt; 中.需要使用 &lt;strong&gt;a&lt;/strong&gt; 中的文字,来使用 &lt;strong&gt;&amp;ldquo;ap&lt;/strong&gt; 命令即可.使用 &lt;strong&gt;:reg&lt;/strong&gt; 命令可以看到所有的 &lt;em&gt;register&lt;/em&gt;, 其中 &lt;em&gt;0~9&lt;/em&gt; 显示了最近删除与复制的一些文字.&lt;/p&gt;

&lt;p&gt;##macro
&lt;em&gt;vim&lt;/em&gt; 的 &lt;em&gt;macro&lt;/em&gt; 是用来录制一段动作,然后保存到命名的 &lt;em&gt;macro&lt;/em&gt; 中去的. 使用方法为:在命令模式下使用 &lt;strong&gt;qa&lt;/strong&gt;命令(&lt;strong&gt;a&lt;/strong&gt;代表 &lt;em&gt;marcro&lt;/em&gt; 名,可以是其他数字与字母).这时候状态栏的左边上会显示 &lt;strong&gt;recording&lt;/strong&gt;, 然后做一些操作,做完后在命令模式下使用 &lt;strong&gt;q&lt;/strong&gt; 命令退出录制.然后就可以使用 &lt;strong&gt;@a&lt;/strong&gt; 将这段 &lt;em&gt;macro&lt;/em&gt; &amp;lsquo;播放&amp;rsquo;出来. 如果需要连续做10次,使用 &lt;strong&gt;10@a&lt;/strong&gt;即可.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>尾递归优化</title>
      <link>http://www.leyafo.com/post/2013-11-23-tail-recursion-optimization/</link>
      <pubDate>Sat, 23 Nov 2013 11:47:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2013-11-23-tail-recursion-optimization/</guid>
      <description>&lt;p&gt;&lt;em&gt;递归是一个奇特的玩意,能简洁的描述复杂的思考.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;一个简单的递归函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fibonacci(n):
    if n &amp;lt;= 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数实现了一个裴波那契数列.非常简单,代码只有 3 行,但如果跟着函数运行的轨迹走.会发现这个函数背后的调用过程非常的复杂.每次递归都会依赖前面两次计算的结果.随着递归的层级上升,每次都会重新去调用前两次计算产生的结果.为了简化描述,下面是以 fibonacci(5) 模拟递归调用过程.
&lt;img src=&#34;http://user-image.logdown.io/user/4793/blog/4808/post/161697/ACy9LF8WSqK0PWHRVX83_fib.png&#34; alt=&#34;fib.png&#34; /&gt;
可以看到,每次递归都会重复前两次的调用过程.实际上这个递归数列并不需要每次都重复去求前两次的结果.如果用压栈的方法,一遍递归就可以搞定了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fibonacci(n):
    L = fibonacci.L
    if n &amp;lt;= 2:
        return L[-1]  #get top
    else:
        n2 = L.pop()  
        n1 = L.pop()
        L.append(n2)  #&#39;append&#39; is stack&#39;s push  
        L.append(n1+n2)
    return fibonacci(n-1)
fibonacci.L = [1,1]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码耍了一个小花招.首先先设定好两个初始的计算结果,然后开始递归迭代.与前一版本递归不同的是,前一个递归需要在进入到递归底部后,才开始跳出来计算每一步递归后的结果,直到返回.而后一个递归会在最开始递归进入时就开始计算,进入到递归底部后(也就是 n &amp;lt;= 2)最终的结果就已经计算出来了,直接一层一层返回这个结果就可以了.
为了便于说明下面代码是利用两个变量做中间结果的版本:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fib(n, n1=1, n2=1):
    if n &amp;lt; 2:
        return n1
    return fib(n-1, n2, n1+n2)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟上面那个压栈的方式一样.先设定好两个默认的结果,在递归进入时直接将结果计算出来并保存好.
下面是这个函数的调用过程:
  fib(n = 10, n1 = 1, n2 = 1)
  fib(n = 9, n1 = 1, n2 = 2)
  fib(n = 8, n1 = 2, n2 = 3)
  fib(n = 7, n1 = 3, n2 = 5)
  fib(n = 6, n1 = 5, n2 = 8)
  fib(n = 5, n1 = 8, n2 = 13)
  fib(n = 4, n1 = 13, n2 = 21)
  fib(n = 3, n1 = 21, n2 = 34)
  fib(n = 2, n1 = 34, n2 = 55)
  fib(n = 1, n1 = 55, n2 = 89)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>