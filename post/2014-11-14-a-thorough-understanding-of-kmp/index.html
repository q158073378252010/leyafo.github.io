<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    


    
        <meta name="twitter:card" content="summary"/>
    



<meta name="twitter:title" content="彻底理解 KMP算法"/>
<meta name="twitter:description" content="KMP 算法是一种子串匹配算法。其特点在于匹配子串时利用已经匹配成功的部分子串来跳转到下一次能再次匹配的串。书上列举的一大堆公式看着很犯晕，网上各类码农博客里面用代码写的文章，让本来逻辑有点绕的 kmp 更加绕。就我最近看到的文章来说最清晰的就是阮一峰 和 详解KMP算法。这两辆篇文章解释的通俗易懂，也有一些不太明晰的地方。本文的目的是在于解释笔者本人在理解 kmp，及阅读这些资料时不明白的地方。 首先还是来看 kmp 匹配子串所使用的方法，下文中字符串“TEST ABCABCABCDEF” 表示要匹配的主串，字符串 &ldquo;ABCABCDEF&rdquo; 表示待匹配的子串。(用肉眼我们可以看到要匹配的子串的位置在最后的位置)。首先像暴力匹配一样我们把不匹配的字符串全部进行匹配并跳过。
TEST ABCABCABCDEF ABCABCDEF | |-------- 进入下一个位置进行匹配 ------&gt; TEST ABCABCABCDEF ABCABCDEF | &lt;----- 还是不匹配,继续往前走 ------| | | ......前面三个还是不匹配..... 这个时候我们待匹配的子串走到了‘TEST ’后面一个位置
TEST ABCABCABCDEF ABCABCDEF | |------ D 和 A 不匹配。 这个时候主串和子串出现了部分匹配的情况，这个时候我们的子串该如何前进继续匹配？目前能想到的方法就是按照暴力匹配的方式继续向前进一步。但本文的目的不在于讨论暴力匹配，所以这种方法被 Pass 掉。如果直接将子串移动到现在不匹配 D 的位置，这种方式会错过可能会匹配的子串。比如下面这种情况会错过可能会匹配的子串。
ABCABCDEFGHIJK -----&gt; ABCABCDEFG ABCDEFG ABCDEFG 因此上面的移动是不合法的，算法会出现错误。从这里我们可以观察到合法的移动是将子串移动到 ABC 。这样我们就能再次匹配到 ABC，这也就是本文前面说的那句话，利用已经匹配成功的部分子串来跳转到下一次能再次匹配的串。现在问题是我们该如何在程序中得到这个正确的移动位置？首先我们先来观察已经匹配的部分匹配子串。
TEST ABCABCABCDEF ABCABCDEF | |---------&gt;部分匹配子串 ABCABC 从这里我们可以看到 ABC 出现了两次，因此 ABC 是我们需要的再次匹配的串。但这个 ABC 是如何得到的？因此我们现在我们需要解决的问题有2个。 1. 找到再次匹配串。 2."/>



  	<meta property="og:title" content=" 彻底理解 KMP算法 &middot;  Doing Right Things" />
  	<meta property="og:site_name" content="Doing Right Things" />
  	<meta property="og:url" content="http://www.leyafo.com/post/2014-11-14-a-thorough-understanding-of-kmp/" />

    
  	<meta property="og:type" content="article" />

    <meta property="og:article:published_time" content="2014-11-14T07:02:00&#43;08:00" />

    
    

    <title>
       彻底理解 KMP算法 &middot;  Doing Right Things
    </title>

    <meta name="description" content="Just Write Some Minds" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="http://www.leyafo.com/images/favicon.ico">
	  <link rel="apple-touch-icon" href="http://www.leyafo.com/images/apple-touch-icon.png" />

    <link rel="stylesheet" type="text/css" href="http://www.leyafo.com/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="http://www.leyafo.com/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />
    
      
          <link href="http://www.leyafo.com/index.xml" rel="alternate" type="application/rss+xml" title="Doing Right Things" />
      
      
    
    <meta name="generator" content="Hugo 0.40.2" />

    <link rel="canonical" href="http://www.leyafo.com/post/2014-11-14-a-thorough-understanding-of-kmp/" />

    

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
        
    </ul>
    
    
    <a class="subscribe-button icon-feed" href="http://www.leyafo.com/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




<header class="main-header post-head no-cover">
  <nav class="main-nav clearfix">


  
  
      <a class="menu-button icon-feed" href="http://www.leyafo.com/index.xml">&nbsp;&nbsp;Subscribe</a>
  
  </nav>
</header>



<main class="content" role="main">




  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">彻底理解 KMP算法</h1>
        <small></small>

        <section class="post-meta">
        
          <time class="post-date" datetime="2014-11-14T07:02:00&#43;08:00">
            Nov 14, 2014
          </time>
        
         
        </section>
    </header>

    <section class="post-content">
      <p><a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KMP</a> 算法是一种子串匹配算法。其特点在于匹配子串时<strong>利用已经匹配成功的部分子串来跳转到下一次能再次匹配的串</strong>。书上列举的一大堆公式看着很犯晕，网上各类码农博客里面用代码写的文章，让本来逻辑有点绕的 kmp 更加绕。就我最近看到的文章来说最清晰的就是<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">阮一峰</a> 和 <a href="http://www.cnblogs.com/yjiyjige/p/3263858.html">详解KMP算法</a>。这两辆篇文章解释的通俗易懂，也有一些不太明晰的地方。本文的目的是在于解释笔者本人在理解 kmp，及阅读这些资料时不明白的地方。
首先还是来看 kmp 匹配子串所使用的方法，下文中字符串“TEST ABCABCABCDEF” 表示要匹配的主串，字符串 &ldquo;ABCABCDEF&rdquo; 表示待匹配的子串。(用肉眼我们可以看到要匹配的子串的位置在最后的位置)。首先像暴力匹配一样我们把不匹配的字符串全部进行匹配并跳过。</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">   TEST ABCABCABCDEF
     ABCABCDEF
   |
   |-------- <span style="color:#a61717;background-color:#e3d2d2">进入下一个位置进行匹配</span> ------&gt;  TEST ABCABCABCDEF
                                          ABCABCDEF
                                          |
          &lt;----- <span style="color:#a61717;background-color:#e3d2d2">还是不匹配</span>,<span style="color:#a61717;background-color:#e3d2d2">继续往前走</span> ------|
          |
          |
          ......<span style="color:#a61717;background-color:#e3d2d2">前面三个还是不匹配</span>.....</code></pre></div>
<p>这个时候我们待匹配的子串走到了‘TEST ’后面一个位置</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">         TEST ABCABCABCDEF
              ABCABCDEF
                    |
                    |------ D <span style="color:#a61717;background-color:#e3d2d2">和</span> A <span style="color:#a61717;background-color:#e3d2d2">不匹配。</span></code></pre></div>
<p>这个时候主串和子串出现了部分匹配的情况，这个时候我们的子串该如何前进继续匹配？目前能想到的方法就是按照暴力匹配的方式继续向前进一步。但本文的目的不在于讨论暴力匹配，所以这种方法被 Pass 掉。如果直接将子串移动到现在不匹配 D 的位置，这种方式会错过<strong>可能会匹配的子串</strong>。比如下面这种情况会错过<strong>可能会匹配的子串</strong>。</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">       ABCABCDEFGHIJK        -----&gt;     ABCABCDEFG
       ABCDEFG                                ABCDEFG</code></pre></div>
<p>因此上面的移动是不合法的，算法会出现错误。从这里我们可以观察到合法的移动是将子串移动到 ABC 。这样我们就能再次匹配到 ABC，这也就是本文前面说的那句话，<strong>利用已经匹配成功的部分子串来跳转到下一次能再次匹配的串</strong>。现在问题是我们该如何在程序中得到这个正确的移动位置？首先我们先来观察已经匹配的部分匹配子串。</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">         TEST ABCABCABCDEF 
              ABCABCDEF
                    |
                    |---------&gt;<span style="color:#a61717;background-color:#e3d2d2">部分匹配子串</span> ABCABC</code></pre></div>
<p>从这里我们可以看到 ABC 出现了两次，因此 ABC 是我们需要的<strong>再次匹配的串</strong>。但这个 ABC 是如何得到的？因此我们现在我们需要解决的问题有2个。
1. 找到<strong>再次匹配串</strong>。
2. 确定这个<strong>再次匹配串</strong>需要移动的位置。</p>

<p>这个时候我们要解决的问题跟主串已经没啥关系了，我们的问题变成了找子串中<strong>重合</strong>的子串。实际上还是找子串，不同的是这次我需要去<strong>分析部分匹配串里面的子串</strong>。这个问题比较好解决，我们只需要把<strong>部分匹配串</strong>全部分解为子串。就能找到出现两次或者两次以上的子串了。因此<em>ABCABC</em> 可以分解为如下子串：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">BCABC
CABC
ABC
BC
C</code></pre></div>
<p>上面是从后面开始分解的子串，这并没有归纳出所有的子串，还需要从前面开始分解。所以还可以从前面分解如下子串：</p>

<pre><code>ABCAB
ABCA
ABC
AB
A
</code></pre>

<p>这就是<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">阮一峰</a>的 blog 中所说的前缀和后缀。引入前缀和后缀的目的是为了找到出现两次以上的子串。现在我们的第一个问题 <strong>找到再次匹配的串</strong>已经解决了，相匹配的子串是‘ABC’。接下来解决第二个问题<strong>确定再次匹配串需要移动的位置</strong>。这个问题看起来有点难，我们可以引入一些已知的条件来得到这个问题的解。<br />
已知条件：
1.部分匹配串的长度
2.出现两次以上子串长度
从上面的前缀和后缀我们可以知道，只需要把相同后缀移动到最前面就能和前缀匹配。因此可以得到下面的公式：
要移动的位置 = 部分匹配的长度 - 出现2次以上的后缀长度。
因此我们最后的结果要移动的结果为</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">         TEST ABCABCABCDEF 
                 ABCABCDEF
                       |
                       |---------&gt;<span style="color:#a61717;background-color:#e3d2d2">移动位</span> <span style="color:#b452cd">6</span> - len(<span style="color:#a61717;background-color:#e3d2d2">&#39;</span>abc<span style="color:#a61717;background-color:#e3d2d2">&#39;</span>)</code></pre></div>
<p>kmp 会把这些部分匹配的子串信息存到一个 next 数组里面。<em>ABCABCDEF</em> 对应的 next 的数组如下：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">                   ABCABCDEF
index         ---&gt; <span style="color:#b452cd">01234567</span><span style="color:#b452cd">8</span>
next          ---&gt; <span style="color:#b452cd">000123000</span></code></pre></div>
    </section>


  <footer class="post-footer">


    

    <section class="author">
  <h4><a href="http://www.leyafo.com/">leyafo</a></h4>
</section>


    

    

  </footer>
</article>

</main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">Doing Right Things</a> All rights reserved by Leyafo</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="http://www.leyafo.com/js/jquery.js"></script>
    <script type="text/javascript" src="http://www.leyafo.com/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="http://www.leyafo.com/js/index.js"></script>
    <script id='nodebb-comments-script' ourl="https://v2mm.tech" ocid="49" blogger='leyafo' src="https://v2mm.tech/plugins/nodebb-plugin-blog-comments2/lib/simple-hugo.js"></script>
    
</body>
</html>

