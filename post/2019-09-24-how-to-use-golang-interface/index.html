<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    


    
        <meta name="twitter:card" content="summary"/>
    



<meta name="twitter:title" content="golang interface 要怎么用？"/>
<meta name="twitter:description" content="golang 的抽象组件并不多，一个 interface 几乎囊括所有抽象所需的设计。interface 可以来实现 duck type，继承，泛型，抽象类这些在其他语言实现的常见抽象。interface 可以说是 golang 这门语言的抽象核心。
面向对象的思考 我们学习面向对象经常讨论的三大毒瘤是：封装，继承，多态。我们先来分析和定义这三大特性，最后再来介绍为什么 golang 一个 interface 就能实现所有的这三大特性。
封装 我们先来思考封装的本质是什么？封装的本质就是把你的代码做成一个可装卸的组件，组件暴露一些接口，用户使用组件时毋需关注内部的实现，只关心接口的输入输出就可以把这个组件集成到代码里面。为了把这一系列的过程更加便捷的描述出来，我们可以把它命名成一个具体的对象，对象里面包含一系列操作。
继承，多态 golang 里面实际上没有继承这个概念。golang 里面把一个 struct 包含到另一个 struct 辅以一定的编译的语法糖看起来像继承一样的抽象实际上不是继承，它还是封装这个概念的升级版。在 golang 里面把这叫做组合式继承。
继承和多态并不能各自分开独立的来看。多态如果脱离继承它将变成另一抽象的概念：duck type。
在其他面向对象的语言里面我们继承一个实体，就拥有父类的所有方法。如果需要对父类同一方法进行覆盖，我们就实现一个同样的方法进行覆盖。这样的目的是让我们为两个不同的对象调用同一个方法。但实现这一点我们为什么需要继承？如果一个对象有一个我们需要的方法，那么我们并不需要关心这具体是个什么对象。这就是 duck type 的概念（如果一个物体会像鸭子一样叫，那么它就是一个鸭子）。 dock type 相对于继承式的多态要更加灵活。如下代码所示：
import ( &#34;fmt&#34; ) type Speaker interface{ Speak() } type Bird struct{ } func (b *Bird)Speak(){ fmt.Println(&#34;zzzzzzzz&#34;) } type People struct{ } func (p *People)Speak(){ fmt.Println(&#34;hello world&#34;) } func main() { var speakers []Speaker speakers = append(speakers, new(Bird), new(People)) for _, s := range(speakers){ s."/>



  	<meta property="og:title" content=" golang interface 要怎么用？ &middot;  Do The Right Things" />
  	<meta property="og:site_name" content="Do The Right Things" />
  	<meta property="og:url" content="http://www.leyafo.com/post/2019-09-24-how-to-use-golang-interface/" />

    
  	<meta property="og:type" content="article" />

    <meta property="og:article:published_time" content="2019-09-24T17:17:18&#43;08:00" />

    
    

    <title>
       golang interface 要怎么用？ &middot;  Do The Right Things
    </title>

    <meta name="description" content="Just Write Some Minds" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="http://www.leyafo.com/images/favicon.ico">
	  <link rel="apple-touch-icon" href="http://www.leyafo.com/images/apple-touch-icon.png" />

    <link rel="stylesheet" type="text/css" href="http://www.leyafo.com/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="http://www.leyafo.com/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />
    
      
          <link href="http://www.leyafo.com/index.xml" rel="alternate" type="application/rss+xml" title="Do The Right Things" />
      
      
    
    <meta name="generator" content="Hugo 0.40.2" />

    <link rel="canonical" href="http://www.leyafo.com/post/2019-09-24-how-to-use-golang-interface/" />

    

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
        
    </ul>
    
    
    <a class="subscribe-button icon-feed" href="http://www.leyafo.com/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




<header class="main-header post-head no-cover">
  <nav class="main-nav clearfix">


  
  
      <a class="menu-button icon-feed" href="http://www.leyafo.com/index.xml">&nbsp;&nbsp;Subscribe</a>
  
  </nav>
</header>



<main class="content" role="main">




  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">golang interface 要怎么用？</h1>
        <small></small>

        <section class="post-meta">
        
          <time class="post-date" datetime="2019-09-24T17:17:18&#43;08:00">
            Sep 24, 2019
          </time>
        
         
        </section>
    </header>

    <section class="post-content">
      

<p>golang 的抽象组件并不多，一个 interface 几乎囊括所有抽象所需的设计。interface 可以来实现 duck type，继承，泛型，抽象类这些在其他语言实现的常见抽象。interface 可以说是 golang 这门语言的抽象核心。</p>

<h2 id="面向对象的思考">面向对象的思考</h2>

<p>我们学习面向对象经常讨论的三大毒瘤是：封装，继承，多态。我们先来分析和定义这三大特性，最后再来介绍为什么 golang 一个 interface 就能实现所有的这三大特性。</p>

<h3 id="封装">封装</h3>

<p>我们先来思考封装的本质是什么？封装的本质就是把你的代码做成一个可装卸的组件，组件暴露一些接口，用户使用组件时毋需关注内部的实现，只关心接口的输入输出就可以把这个组件集成到代码里面。为了把这一系列的过程更加便捷的描述出来，我们可以把它命名成一个具体的对象，对象里面包含一系列操作。</p>

<h3 id="继承-多态">继承，多态</h3>

<p>golang 里面实际上没有继承这个概念。golang 里面把一个 struct 包含到另一个 struct 辅以一定的编译的语法糖看起来像继承一样的抽象实际上不是继承，它还是封装这个概念的升级版。在 golang 里面把这叫做<strong>组合式继承</strong>。<br />
继承和多态并不能各自分开独立的来看。多态如果脱离继承它将变成另一抽象的概念：duck type。<br />
在其他面向对象的语言里面我们继承一个实体，就拥有父类的所有方法。如果需要对父类同一方法进行覆盖，我们就实现一个同样的方法进行覆盖。这样的目的是让我们为两个不同的对象调用同一个方法。但实现这一点我们为什么需要继承？如果一个对象有一个我们需要的方法，那么我们并不需要关心这具体是个什么对象。这就是 duck type 的概念（如果一个物体会像鸭子一样叫，那么它就是一个鸭子）。 dock type 相对于继承式的多态要更加灵活。如下代码所示：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#8b008b;font-weight:bold">import</span> (
	<span style="color:#cd5555">&#34;fmt&#34;</span>
)

<span style="color:#8b008b;font-weight:bold">type</span> Speaker <span style="color:#8b008b;font-weight:bold">interface</span>{
   Speak()
}
<span style="color:#8b008b;font-weight:bold">type</span> Bird <span style="color:#8b008b;font-weight:bold">struct</span>{

}
<span style="color:#8b008b;font-weight:bold">func</span> (b *Bird)Speak(){
    fmt.Println(<span style="color:#cd5555">&#34;zzzzzzzz&#34;</span>)
}
<span style="color:#8b008b;font-weight:bold">type</span> People <span style="color:#8b008b;font-weight:bold">struct</span>{
}
<span style="color:#8b008b;font-weight:bold">func</span> (p *People)Speak(){
    fmt.Println(<span style="color:#cd5555">&#34;hello world&#34;</span>)
}

<span style="color:#8b008b;font-weight:bold">func</span> main() {
	<span style="color:#8b008b;font-weight:bold">var</span> speakers []Speaker
	speakers = <span style="color:#658b00">append</span>(speakers, <span style="color:#658b00">new</span>(Bird), <span style="color:#658b00">new</span>(People))
	<span style="color:#8b008b;font-weight:bold">for</span> _, s := <span style="color:#8b008b;font-weight:bold">range</span>(speakers){
		s.Speak()
	}
}</code></pre></div>
<p>如上所示我们不需要关心 bird 和 people 是否有同一个共同的父类，或者是否都继承自 Object 这个祖先类。我们不需要关心对象，只需要关心是否能方便的把代码组织到一起。封装实际上是所有编程语言的基础要素，它本质上就是<strong>代码复用</strong>和你的代码是否<strong>面向对象</strong>没有任何的关系。而 interface 是我们代码抽象的一种方式，它只关心我们要做到事情，并不关心它属于一个什么<strong>对象</strong>。所以在 golang 里面我们没有 <strong>has-a</strong> 和 <strong>is-a</strong> 这两个概念的困惑。在 golang 里面网络传输，文件读写，编解码用 reader 和 writer 这两个接口抽象起来非常自然。</p>

<h2 id="interface">interface{}</h2>

<p>golang 经常被人诟病的一点就是它没有泛型，但泛型反对者们说 <code>interface{}</code> 就是泛型，可以拿来做为泛型用。这种说法是不对的。 <code>interface{}</code> 它不是泛型，它是一个接口，这个接口可以适配任何类型。它与 void 又不太一样，它会保存传入对象的 value 和 type 信息。<br />
使用 <code>interface{}</code> 的时候我们重点需要关注的怎样传递 value，而不是用来抽象接口的设计。当一个接口没有明确的输入输出的信息，那这是个糟糕的接口，它会让使用接口的人非常困惑。</p>

<h2 id="interface-receiver">interface receiver</h2>

<p>在 struct 上 bind 一个 function 有 pointer 和 value 的区别。在调用的时候没有区别，但在 interface 的实现上，需要明确的指定传递的对象是一个 pointer 还是非 pointer。这也是使用 interface 有点迷惑的地方。如下代码所示：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#8b008b;font-weight:bold">import</span> (
	<span style="color:#cd5555">&#34;fmt&#34;</span>
)

<span style="color:#8b008b;font-weight:bold">type</span> Speaker <span style="color:#8b008b;font-weight:bold">interface</span>{
   Speak()
}

<span style="color:#8b008b;font-weight:bold">type</span> People <span style="color:#8b008b;font-weight:bold">struct</span>{
   Age <span style="color:#00688b;font-weight:bold">int</span>
}
<span style="color:#8b008b;font-weight:bold">func</span> (p *People)Speak(){
    fmt.Println(<span style="color:#cd5555">&#34;hello world&#34;</span>)
}

<span style="color:#8b008b;font-weight:bold">func</span> main() {
	p1 := <span style="color:#658b00">new</span>(People)
	p1.Speak()
	p2 := &amp;People{}
	p2.Speak()

	<span style="color:#8b008b;font-weight:bold">var</span> speakers []Speaker
	<span style="color:#228b22">//Can&#39;t compile
</span><span style="color:#228b22"></span>	<span style="color:#228b22">//speakers = append(speakers, new(People), People{})
</span><span style="color:#228b22"></span>	speakers = <span style="color:#658b00">append</span>(speakers, <span style="color:#658b00">new</span>(People), &amp;People{})
	<span style="color:#8b008b;font-weight:bold">for</span> _, s := <span style="color:#8b008b;font-weight:bold">range</span>(speakers){
		s.Speak()
	}
}</code></pre></div>
<h2 id="interface-现实应用案例分析">interface 现实应用案例分析</h2>

<p>从 java 转过来的同学容易对 interface 进行滥用，在不必要使用 interface 的地方使用 interface。如下代码就是一位写 java 的同学转过来写 golang 的代码。</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">    <span style="color:#8b008b;font-weight:bold">type</span> RemoteClienter <span style="color:#8b008b;font-weight:bold">interface</span>{
        <span style="color:#8b008b;font-weight:bold">func</span> Start(addr <span style="color:#00688b;font-weight:bold">string</span>)
        <span style="color:#8b008b;font-weight:bold">func</span> Send([]<span style="color:#00688b;font-weight:bold">byte</span>)(<span style="color:#00688b;font-weight:bold">int</span>, <span style="color:#00688b;font-weight:bold">error</span>)
        <span style="color:#8b008b;font-weight:bold">func</span> AsyncSend([]<span style="color:#00688b;font-weight:bold">byte</span>)(<span style="color:#00688b;font-weight:bold">int</span>, <span style="color:#00688b;font-weight:bold">error</span>)
    }</code></pre></div>
<p>这段代码的目的是抽象不同的 client，它可以通过 http，tcp，或者其他协议进行同步或异步网络数据发送。单纯的从这个目的推断这个接口的实现是没有问题的。但我们为什么要去抽象一个 client？我们为什么需要关心接口的数据发送是同步还是异步的？这个 client 我们实际上只需要关心数据是否可以发出去，至于用什么协议，同步还是异步发送这些问题根本不重要。因此这个接口更适合用 golang 的 writer 接口抽象。如下所示：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang">    <span style="color:#8b008b;font-weight:bold">type</span> Wirter <span style="color:#8b008b;font-weight:bold">interface</span>{
        <span style="color:#8b008b;font-weight:bold">func</span> Write([]<span style="color:#00688b;font-weight:bold">byte</span>)(<span style="color:#00688b;font-weight:bold">int</span>, <span style="color:#00688b;font-weight:bold">error</span>)
    }</code></pre></div>
    </section>


  <footer class="post-footer">


    

    <section class="author">
  <h4><a href="http://www.leyafo.com/">leyafo</a></h4>
</section>


    

    

  </footer>
</article>

</main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">Do The Right Things</a> All rights reserved by Leyafo</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="http://www.leyafo.com/js/jquery.js"></script>
    <script type="text/javascript" src="http://www.leyafo.com/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="http://www.leyafo.com/js/index.js"></script>
    <script id='nodebb-comments-script' ourl="https://v2mm.tech" ocid="49" blogger='leyafo' src="https://v2mm.tech/plugins/nodebb-plugin-blog-comments2/lib/simple-hugo.js"></script>
    
</body>
</html>

