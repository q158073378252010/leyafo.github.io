<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.58.3" />

  

  

  
  <title>go 语言错误处理</title>
  

  <style>
body {
  color: #000000;
  line-height: 1.6em;
  padding: 1em;
  margin: auto;
  max-width: 72em;
  background: #fefefe;
  font-family: Fira Code,Monaco,Consolas,Ubuntu Mono,PingFang SC,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,monospace,sans-serif;
}

nav {
    margin-bottom: 20px;
}
a:visited{
  color: grey;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255,255,255,.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255,255,255,1);
}






.comments{
    text-align: center;
    margin-top: 20px;
    padding: 5px 10px;
    font-size: .8rem;
    text-transform: uppercase;
    text-decoration: none;
    letter-spacing: .1em;
    z-index: 1;
}

.utterances{
  max-width: 100%;
}


.hr-middle-text{
  line-height: 1em;
  position: relative;
  outline: 0;
  border: 0;
  color: black;
  text-align: center;
  height: 1.5em;
  opacity: .5;
}
.hr-middle-text:before {
    content: '';
    
    
    
    background: linear-gradient(to right, transparent, black, transparent);
    position: absolute;
    left: 0;
    top: 50%;
    width: 100%;
    height: 1px;
}
.hr-middle-text:after{
    content: attr(data-content);
    position: relative;
    display: inline-block;
    color: black;

    padding: 0 .5em;
    line-height: 1.5em;
    
    
    background-color: #fcfcfa;
}

</style>

</head>


<body>
  <header>
<nav>
  [ <a class="nav-btn" href="http://www.leyafo.com/">Home</a> ] 
  [ <a class="nav-btn" href="http://www.leyafo.com/about.html">About</a> ] 
  [ <a class="nav-btn" href="http://www.leyafo.com/contact.html">Contact</a> ] 
</nav>
</header>
  
  <div>
    <article>
      <h1>go 语言错误处理</h1>
<p>
  <small class="text-secondary">
  
  
  November 25, 2019
  </small>
  
</p>
<p>go 语言错误处理非常简单清晰且有效。你只需要记住一个原则：“Whatever you do, always check your errors!”。这条原则很简单，我们只要在有 error 值返回的函数外处理所有的 error 即可。但这带来一个问题，我们的代码里面会大量充斥着如下代码：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">Foo</span>() (err <span style="color:#00688b;font-weight:bold">error</span>){
    err = <span style="color:#008b45">Bar</span>()
    <span style="color:#8b008b;font-weight:bold">if</span> err != <span style="color:#8b008b;font-weight:bold">nil</span>{
        <span style="color:#8b008b;font-weight:bold">return</span> err
    }
    err = <span style="color:#008b45">Bar</span>()
    <span style="color:#8b008b;font-weight:bold">if</span> err != <span style="color:#8b008b;font-weight:bold">nil</span>{
       <span style="color:#8b008b;font-weight:bold">return</span> err
    }
    err = <span style="color:#008b45">Bar</span>()
    <span style="color:#8b008b;font-weight:bold">if</span> err != <span style="color:#8b008b;font-weight:bold">nil</span>{
       <span style="color:#8b008b;font-weight:bold">return</span> err
    }
    <span style="color:#228b22">//....
</span><span style="color:#228b22"></span>}</code></pre></div>
<p>对于这个问题，rob pike 在他的那篇 errors are values 文章里建议是写一个同样的接口去包装返回 error 的接口，然后每次重复调用时就不用再反复的检查 error 值。类似如下的方式</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">Foo</span>() <span style="color:#00688b;font-weight:bold">error</span>{
    <span style="color:#8b008b;font-weight:bold">var</span> err <span style="color:#00688b;font-weight:bold">error</span>
    <span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">newBar</span>(){
        <span style="color:#8b008b;font-weight:bold">if</span> err != <span style="color:#8b008b;font-weight:bold">nil</span>{
           <span style="color:#8b008b;font-weight:bold">return</span>
        }
        err = <span style="color:#008b45">Bar</span>()
        <span style="color:#8b008b;font-weight:bold">return</span> 
    }
    <span style="color:#008b45">newBar</span>()
    <span style="color:#008b45">newBar</span>()
    <span style="color:#008b45">newBar</span>()
    ...
    <span style="color:#8b008b;font-weight:bold">return</span> err
}</code></pre></div>
<p>这个方式有效且简单，省略非常多繁琐的 <code>if err != nil</code> 的判断。（请忽略函数调用开销）。实际上 bufio 里面的 Scan 接口就是这么实现的。如果我们的函数里面分别调用不同的函数，并且它们除 error 以外的返回值是不同的类型，这个方法就会失效。因此新版的 golang 里面的 <a href="https://dev.to/deanveloper/go-2-draft-error-handling-3loo">error handle</a> 给出如下类似 try catch 的实现机制：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">ParseJson</span>(name <span style="color:#00688b;font-weight:bold">string</span>) (Parsed, <span style="color:#00688b;font-weight:bold">error</span>) {
    handle err {
        <span style="color:#8b008b;font-weight:bold">return</span> fmt.<span style="color:#008b45">Errorf</span>(<span style="color:#cd5555">&#34;parsing json: %s %v&#34;</span>, name, err)
    }

    <span style="color:#228b22">// Open the file
</span><span style="color:#228b22"></span>    f := check os.<span style="color:#008b45">Open</span>(name)
    <span style="color:#8b008b;font-weight:bold">defer</span> f.<span style="color:#008b45">Close</span>()

    <span style="color:#228b22">// Parse json into p
</span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">var</span> p Parsed
    check json.<span style="color:#008b45">NewDecoder</span>(f).<span style="color:#008b45">Decode</span>(&amp;p)

    <span style="color:#8b008b;font-weight:bold">return</span> p
}</code></pre></div>
<p>它就是为了解决频繁检查 error 而发明的一个机制。它与 try catch 不一样的是只将错误检查固定在函数的内部并只针对 error 类型做判断。这种方式更像是一个语法糖，至于以后会不会加入到 golang 里面我们拭目以待吧。</p>

<p>在 golang 的标准库里面，我们能看到 errors 这个库，其中里面有一个 <code>New(text string) error</code> 这样的接口，它帮助我们构造一个错误，并以传入的 text 做为错误信息。而 fmt 里面也有一个 <code>Errorf(format string, a ...interface{}) error</code> 接口，以 fmt 形式帮助我们构造一个错误。这里我们会误以为这两个接口实现的功能是重叠的，看起来 errors.New 的接口好像没有必要存在一样。如果你与我有同样疑惑时，证明你并没有完全理解 golang 里面的错误处理机制。即使 rob pike 一直在不同的地方反复强调 &ldquo;errors are values&rdquo; 这条原则，但 golang 里面的 error 是有可以类型的。golang 没有 try catch 那样复杂的异常类型判断，为了解决现实中我们需要对不同类型做出不同处理的问题，我需要使用 error.New 构造一个错误类型。<br />
这种应用场景典型的就是 io.Reader 这个接口。当我们需要判断一个数据 stream 是否已经读到 EOF(end of File) 的状态时，我们需要为其构造一个 <code>errors.New(&quot;EOF&quot;)</code> 的错误接口，如果没有这个错误类型标志 io.Reader 接口无法判断数据是否已经读到结束。<br />
我们可以通过 reader 接口的实现想象一下如果没有 EOF 这个错误标志。我们该如何判断数据已经读完？</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8b008b;font-weight:bold">type</span> Reader <span style="color:#8b008b;font-weight:bold">interface</span> {
    <span style="color:#008b45">Read</span>(p []<span style="color:#00688b;font-weight:bold">byte</span>) (n <span style="color:#00688b;font-weight:bold">int</span>, err <span style="color:#00688b;font-weight:bold">error</span>)
}

<span style="color:#8b008b;font-weight:bold">func</span> (f Foo)<span style="color:#008b45">Reader</span>(p []<span style="color:#00688b;font-weight:bold">byte</span>)(n <span style="color:#00688b;font-weight:bold">int</span>, err <span style="color:#00688b;font-weight:bold">error</span>){
    <span style="color:#228b22">//已经没有数据可读
</span><span style="color:#228b22"></span>}</code></pre></div>
<p>试想一下，上面的 <code>reader</code> 这个接口已经没有数据可读，但我们需要让外界知道这个信息，我们该如何返回？
1. 如果返回 <code>n = -1</code> 做为标志，那么是不是表示 n 同时作为一个状态值返回？如果这样，n 这个返回值就会产生二义性。<br />
2. 如果返回 <code>EOF</code> 标志，它并不是一个错误状态，而是一个标志状态。
以上两种方式并不 100% 完美，但第二种方式比第一种方式更符合逻辑直觉。<br />
如果我们在 pkg 层面暴露一个错误的标志给外界作为判断，使用这个错误标志的用户会需要依赖我们的 pkg 才能使用，并且是强依赖。因此我们在设计模块时需要考虑把错误标志做为 API 接口的一部分。为了只将错误类型与我们的模块关联，我们可以选择不内部包装 error 标志，不暴露给外界去做错误类型判断。</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">pkg foo
fooError = errors.<span style="color:#008b45">New</span>(<span style="color:#cd5555">&#34;foo&#34;</span>)
<span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">IsFooError</span>(err <span style="color:#00688b;font-weight:bold">error</span>)<span style="color:#00688b;font-weight:bold">bool</span>{
    _, ok = err.(fooError)
    <span style="color:#8b008b;font-weight:bold">return</span> ok
}</code></pre></div>
<p>现在我们可以很清晰的知道，<code>errors.New</code> 是用来构造一个错误类型，<code>fmt.Errorf</code> 只是用来构造一个错误信息。在构造一个类型信息的时候它的错误值是固定的，因此只能用 <code>errors.New</code> 来进行构造。从这里我们可以看出 <code>errors.New</code> 只是一个常量的 string 值，它是在编译时确定的，<code>fmt.Errorf</code> 是一个运行时确定的变量值。现在我们还是回到了 &ldquo;errors are values&rdquo; 这一原则。</p>

<p>提到错误处理我们不能忽略 panic 和 restore 这一对函数。它俩长得非常像 try catch，看起来也是互相配对使用，这也是我们会让我们的 panic 形成错误的理解。在 golang 里面 panic 表示无法恢复的失败，比如空指针访问，程序奔溃，数组越界，这样严重的错误。restore 可以捕获程序的 panic 错误。在严格的意义上来说，我们不应该去恢复 panic 的错误。restore 的作用是为了记录 panic 的现场信息而准备的，它的作用更像是黑匣子的作用。另外对于需要长期运行不能停的服务端应用，我们可以使用 restore 来程序局部的 bug 造成的以外奔溃。比如我们可以在 http 的入口处去设置 restore 函数，确保当某一个 API 发生错误时不影响其他的 API 正常运行。<br />
记住： <strong>panic 和 restore 并不是成对使用，也不能用来捕获错误。</strong></p>

<p>参考文章：
<a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a>
<a href="https://blog.golang.org/errors-are-values">Errors are values</a></p>

<div class="comments">
  <hr class="hr-middle-text" data-content="COMMENTS">
  <script src="https://utteranc.es/client.js" repo="leyafo/leyafo.github.io" issue-term="title" label="Commnets" theme="github-light" crossorigin="anonymous" async >
  </script>
</div>
    </article>
  </div>
</body>
</html>
