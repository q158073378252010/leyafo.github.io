<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    


    
        <meta name="twitter:card" content="summary"/>
    



<meta name="twitter:title" content="go 语言错误处理"/>
<meta name="twitter:description" content="go 语言错误处理非常简单清晰且有效。你只需要记住一个原则：“Whatever you do, always check your errors!”。这条原则很简单，我们只要在有 error 值返回的函数外处理所有的 error 即可。但这带来一个问题，我们的代码里面会大量充斥着如下代码：
func Foo() (err error){ err = Bar() if err != nil{ return err } err = Bar() if err != nil{ return err } err = Bar() if err != nil{ return err } //.... } 对于这个问题，rob pike 在他的那篇 errors are values 文章里建议是写一个同样的接口去包装返回 error 的接口，然后每次重复调用时就不用再反复的检查 error 值。类似如下的方式
func Foo() error{ var err error func newBar(){ if err != nil{ return } err = Bar() return } newBar() newBar() newBar() ."/>



  	<meta property="og:title" content=" go 语言错误处理 &middot;  Do The Right Things" />
  	<meta property="og:site_name" content="Do The Right Things" />
  	<meta property="og:url" content="http://www.leyafo.com/post/2019-11-25-golang-errors/" />

    
  	<meta property="og:type" content="article" />

    <meta property="og:article:published_time" content="2019-11-25T10:46:25&#43;08:00" />

    
    

    <title>
       go 语言错误处理 &middot;  Do The Right Things
    </title>

    <meta name="description" content="Just Write Some Minds" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="http://www.leyafo.com/images/favicon.ico">
	  <link rel="apple-touch-icon" href="http://www.leyafo.com/images/apple-touch-icon.png" />

    <link rel="stylesheet" type="text/css" href="http://www.leyafo.com/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="http://www.leyafo.com/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />
    
      
          <link href="http://www.leyafo.com/index.xml" rel="alternate" type="application/rss+xml" title="Do The Right Things" />
      
      
    
    <meta name="generator" content="Hugo 0.71.0" />

    <link rel="canonical" href="http://www.leyafo.com/post/2019-11-25-golang-errors/" />

    

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
        
    </ul>
    
    
    <a class="subscribe-button icon-feed" href="http://www.leyafo.com/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




<header class="main-header post-head no-cover">
  <nav class="main-nav clearfix">


  
  
      <a class="menu-button icon-feed" href="http://www.leyafo.com/index.xml">&nbsp;&nbsp;Subscribe</a>
  
  </nav>
</header>



<main class="content" role="main">




  <article class="post post">

    <header class="post-header">
        <h3 class="post-title">go 语言错误处理</h3>
        <small></small>

        <section class="post-meta">
        
          <time class="post-date" datetime="2019-11-25T10:46:25&#43;08:00">
            Nov 25, 2019
          </time>
        
         
        </section>
    </header>

    <section class="post-content">
      <p>go 语言错误处理非常简单清晰且有效。你只需要记住一个原则：“Whatever you do, always check your errors!”。这条原则很简单，我们只要在有 error 值返回的函数外处理所有的 error 即可。但这带来一个问题，我们的代码里面会大量充斥着如下代码：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">Foo</span>() (err <span style="color:#00688b;font-weight:bold">error</span>){
    err = <span style="color:#008b45">Bar</span>()
    <span style="color:#8b008b;font-weight:bold">if</span> err != <span style="color:#8b008b;font-weight:bold">nil</span>{
        <span style="color:#8b008b;font-weight:bold">return</span> err
    }
    err = <span style="color:#008b45">Bar</span>()
    <span style="color:#8b008b;font-weight:bold">if</span> err != <span style="color:#8b008b;font-weight:bold">nil</span>{
       <span style="color:#8b008b;font-weight:bold">return</span> err
    }
    err = <span style="color:#008b45">Bar</span>()
    <span style="color:#8b008b;font-weight:bold">if</span> err != <span style="color:#8b008b;font-weight:bold">nil</span>{
       <span style="color:#8b008b;font-weight:bold">return</span> err
    }
    <span style="color:#228b22">//....
</span><span style="color:#228b22"></span>}
</code></pre></div><p>对于这个问题，rob pike 在他的那篇 errors are values 文章里建议是写一个同样的接口去包装返回 error 的接口，然后每次重复调用时就不用再反复的检查 error 值。类似如下的方式</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">Foo</span>() <span style="color:#00688b;font-weight:bold">error</span>{
    <span style="color:#8b008b;font-weight:bold">var</span> err <span style="color:#00688b;font-weight:bold">error</span>
    <span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">newBar</span>(){
        <span style="color:#8b008b;font-weight:bold">if</span> err != <span style="color:#8b008b;font-weight:bold">nil</span>{
           <span style="color:#8b008b;font-weight:bold">return</span>
        }
        err = <span style="color:#008b45">Bar</span>()
        <span style="color:#8b008b;font-weight:bold">return</span> 
    }
    <span style="color:#008b45">newBar</span>()
    <span style="color:#008b45">newBar</span>()
    <span style="color:#008b45">newBar</span>()
    ...
    <span style="color:#8b008b;font-weight:bold">return</span> err
}
</code></pre></div><p>这个方式有效且简单，省略非常多繁琐的 <code>if err != nil</code> 的判断。（请忽略函数调用开销）。实际上 bufio 里面的 Scan 接口就是这么实现的。如果我们的函数里面分别调用不同的函数，并且它们除 error 以外的返回值是不同的类型，这个方法就会失效。因此新版的 golang 里面的 <a href="https://dev.to/deanveloper/go-2-draft-error-handling-3loo">error handle</a> 给出如下类似 try catch 的实现机制：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">ParseJson</span>(name <span style="color:#00688b;font-weight:bold">string</span>) (Parsed, <span style="color:#00688b;font-weight:bold">error</span>) {
    handle err {
        <span style="color:#8b008b;font-weight:bold">return</span> fmt.<span style="color:#008b45">Errorf</span>(<span style="color:#cd5555">&#34;parsing json: %s %v&#34;</span>, name, err)
    }

    <span style="color:#228b22">// Open the file
</span><span style="color:#228b22"></span>    f := check os.<span style="color:#008b45">Open</span>(name)
    <span style="color:#8b008b;font-weight:bold">defer</span> f.<span style="color:#008b45">Close</span>()

    <span style="color:#228b22">// Parse json into p
</span><span style="color:#228b22"></span>    <span style="color:#8b008b;font-weight:bold">var</span> p Parsed
    check json.<span style="color:#008b45">NewDecoder</span>(f).<span style="color:#008b45">Decode</span>(&amp;p)

    <span style="color:#8b008b;font-weight:bold">return</span> p
}
</code></pre></div><p>它就是为了解决频繁检查 error 而发明的一个机制。它与 try catch 不一样的是只将错误检查固定在函数的内部并只针对 error 类型做判断。这种方式更像是一个语法糖，至于以后会不会加入到 golang 里面我们拭目以待吧。</p>
<p>在 golang 的标准库里面，我们能看到 errors 这个库，其中里面有一个 <code>New(text string) error</code> 这样的接口，它帮助我们构造一个错误，并以传入的 text 做为错误信息。而 fmt 里面也有一个 <code>Errorf(format string, a ...interface{}) error</code> 接口，以 fmt 形式帮助我们构造一个错误。这里我们会误以为这两个接口实现的功能是重叠的，看起来 errors.New 的接口好像没有必要存在一样。如果你与我有同样疑惑时，证明你并没有完全理解 golang 里面的错误处理机制。即使 rob pike 一直在不同的地方反复强调 &ldquo;errors are values&rdquo; 这条原则，但 golang 里面的 error 是有可以类型的。golang 没有 try catch 那样复杂的异常类型判断，为了解决现实中我们需要对不同类型做出不同处理的问题，我需要使用 error.New 构造一个错误类型。<br>
这种应用场景典型的就是 io.Reader 这个接口。当我们需要判断一个数据 stream 是否已经读到 EOF(end of File) 的状态时，我们需要为其构造一个 <code>errors.New(&quot;EOF&quot;)</code> 的错误接口，如果没有这个错误类型标志 io.Reader 接口无法判断数据是否已经读到结束。<br>
我们可以通过 reader 接口的实现想象一下如果没有 EOF 这个错误标志。我们该如何判断数据已经读完？</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8b008b;font-weight:bold">type</span> Reader <span style="color:#8b008b;font-weight:bold">interface</span> {
    <span style="color:#008b45">Read</span>(p []<span style="color:#00688b;font-weight:bold">byte</span>) (n <span style="color:#00688b;font-weight:bold">int</span>, err <span style="color:#00688b;font-weight:bold">error</span>)
}

<span style="color:#8b008b;font-weight:bold">func</span> (f Foo)<span style="color:#008b45">Reader</span>(p []<span style="color:#00688b;font-weight:bold">byte</span>)(n <span style="color:#00688b;font-weight:bold">int</span>, err <span style="color:#00688b;font-weight:bold">error</span>){
    <span style="color:#228b22">//已经没有数据可读
</span><span style="color:#228b22"></span>}
</code></pre></div><p>试想一下，上面的 <code>reader</code> 这个接口已经没有数据可读，但我们需要让外界知道这个信息，我们该如何返回？</p>
<ol>
<li>如果返回 <code>n = -1</code> 做为标志，那么是不是表示 n 同时作为一个状态值返回？如果这样，n 这个返回值就会产生二义性。</li>
<li>如果返回 <code>EOF</code> 标志，它并不是一个错误状态，而是一个标志状态。
以上两种方式并不 100% 完美，但第二种方式比第一种方式更符合逻辑直觉。<br>
如果我们在 pkg 层面暴露一个错误的标志给外界作为判断，使用这个错误标志的用户会需要依赖我们的 pkg 才能使用，并且是强依赖。因此我们在设计模块时需要考虑把错误标志做为 API 接口的一部分。为了只将错误类型与我们的模块关联，我们可以选择不内部包装 error 标志，不暴露给外界去做错误类型判断。</li>
</ol>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">pkg foo
fooError = errors.<span style="color:#008b45">New</span>(<span style="color:#cd5555">&#34;foo&#34;</span>)
<span style="color:#8b008b;font-weight:bold">func</span> <span style="color:#008b45">IsFooError</span>(err <span style="color:#00688b;font-weight:bold">error</span>)<span style="color:#00688b;font-weight:bold">bool</span>{
    _, ok = err.(fooError)
    <span style="color:#8b008b;font-weight:bold">return</span> ok
}
</code></pre></div><p>现在我们可以很清晰的知道，<code>errors.New</code> 是用来构造一个错误类型，<code>fmt.Errorf</code> 只是用来构造一个错误信息。在构造一个类型信息的时候它的错误值是固定的，因此只能用 <code>errors.New</code> 来进行构造。从这里我们可以看出 <code>errors.New</code> 只是一个常量的 string 值，它是在编译时确定的，<code>fmt.Errorf</code> 是一个运行时确定的变量值。现在我们还是回到了 &ldquo;errors are values&rdquo; 这一原则。</p>
<p>提到错误处理我们不能忽略 panic 和 restore 这一对函数。它俩长得非常像 try catch，看起来也是互相配对使用，这也是我们会让我们的 panic 形成错误的理解。在 golang 里面 panic 表示无法恢复的失败，比如空指针访问，程序奔溃，数组越界，这样严重的错误。restore 可以捕获程序的 panic 错误。在严格的意义上来说，我们不应该去恢复 panic 的错误。restore 的作用是为了记录 panic 的现场信息而准备的，它的作用更像是黑匣子的作用。另外对于需要长期运行不能停的服务端应用，我们可以使用 restore 来程序局部的 bug 造成的以外奔溃。比如我们可以在 http 的入口处去设置 restore 函数，确保当某一个 API 发生错误时不影响其他的 API 正常运行。<br>
记住： <strong>panic 和 restore 并不是成对使用，也不能用来捕获错误。</strong></p>
<p>参考文章：
<a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a>
<a href="https://blog.golang.org/errors-are-values">Errors are values</a></p>

    </section>


  <footer class="post-footer">


    

    <section class="author">
  <h4><a href="http://www.leyafo.com/">leyafo</a></h4>
</section>


    

    

  </footer>
</article>

</main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">Do The Right Things</a> All rights reserved by Leyafo</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="http://www.leyafo.com/js/jquery.js"></script>
    <script type="text/javascript" src="http://www.leyafo.com/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="http://www.leyafo.com/js/index.js"></script>
    <script id='nodebb-comments-script' ourl="https://v2mm.tech" ocid="49" blogger='leyafo' src="https://v2mm.tech/plugins/nodebb-plugin-blog-comments2/lib/simple-hugo.js"></script>
    
</body>
</html>

