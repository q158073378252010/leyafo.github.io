<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.58.3" />

  

  

  
  <title>avl 树的实现</title>
  

  <style>
body {
  color: #000000;
  line-height: 1.6em;
  padding: 1em;
  margin: auto;
  max-width: 72em;
  background: #fefefe;
  font-family: Fira Code,Monaco,Consolas,Ubuntu Mono,PingFang SC,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,monospace,sans-serif;
}

nav {
    margin-bottom: 20px;
}
a:visited{
  color: grey;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255,255,255,.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255,255,255,1);
}






.comments{
    text-align: center;
    margin-top: 20px;
    padding: 5px 10px;
    font-size: .8rem;
    text-transform: uppercase;
    text-decoration: none;
    letter-spacing: .1em;
    z-index: 1;
}

.utterances{
  max-width: 100%;
}


.hr-middle-text{
  line-height: 1em;
  position: relative;
  outline: 0;
  border: 0;
  color: black;
  text-align: center;
  height: 1.5em;
  opacity: .5;
}
.hr-middle-text:before {
    content: '';
    
    
    
    background: linear-gradient(to right, transparent, black, transparent);
    position: absolute;
    left: 0;
    top: 50%;
    width: 100%;
    height: 1px;
}
.hr-middle-text:after{
    content: attr(data-content);
    position: relative;
    display: inline-block;
    color: black;

    padding: 0 .5em;
    line-height: 1.5em;
    
    
    background-color: #fcfcfa;
}

</style>

</head>


<body>
  <header>
<nav>
  [ <a class="nav-btn" href="http://www.leyafo.com/">Home</a> ] 
  [ <a class="nav-btn" href="http://www.leyafo.com/about.html">About</a> ] 
  [ <a class="nav-btn" href="http://www.leyafo.com/contact.html">Contact</a> ] 
</nav>
</header>
  
  <div>
    <article>
      <h1>avl 树的实现</h1>
<p>
  <small class="text-secondary">
  
  
  February 9, 2014
  </small>
  
</p>
<p>过年在家没事，找出了几年前把我折磨得死去活来的<a href="http://book.douban.com/subject/1971825/">&lt;数据结构与算法分析&gt;</a>这本书。确切的说，这段时间这本书也在折磨我。上面的avl树的旋转说得不清不楚的，而且还是使用递归实现了avl树的插入与删除操作。让这本书上本身就已经不太清晰的描述变得更加的扑朔迷离，让我有一种想烧掉这本书的冲动。到最后我实在没法看懂书上描述的avl树的操作方式只好自己从网上找一些资料实现了avl树(<a href="https://github.com/leyafo/practice-algorithm/blob/master/DataStruct/avl_tree.c">代码在此</a>)。另外<a href="http://zh.wikipedia.org/wiki/AVL%E6%A0%91">维基百科</a>上有关于avl树基本性质的描述，我在这里也不过多介绍。但是请勿对照这篇文章去实现avl树，这篇描述的删除操作是有问题的。关于树的旋转，这篇文章也没有把最根本的问题说清楚。avl树最难的部分就是关于树的旋转，本文主要讨旋转的问题。</p>

<p>首先，旋转的作用是降低子树的高度。旋转的方式有两种，一种是用来降低左子树高度一般被称作右旋。一种是用来降低右子树高度一般被称为左旋。这两种旋转在物理上是对称的，在编码上也是无脑对称的。因此，在编码方面我们只需要实现出一种旋转后另一种旋转也可以依葫芦画瓢的实现出来。另外在每个节点中保存一个父节点可以让编码的复杂度大大降低。</p>

<p>下面是左旋的具体变化过程:</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">      A                            B  
       <span style="color:#a61717;background-color:#e3d2d2">\</span>                          / <span style="color:#a61717;background-color:#e3d2d2">\</span>  
        B         <span style="color:#a61717;background-color:#e3d2d2">左旋</span> ==&gt;        A   C   
         <span style="color:#a61717;background-color:#e3d2d2">\</span>    
          C   </code></pre></div>
<p>下面是右旋的具体变化过程:</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">          A                      B   
         /                      / <span style="color:#a61717;background-color:#e3d2d2">\</span>    
        B         <span style="color:#a61717;background-color:#e3d2d2">右旋</span> ==&gt;      C   A    
       /                            
      C   </code></pre></div>
<p>上面的这两种情况是比较理想的情况，在实际的使用情况下是没有这么理想的。不能处理下面这些情况。</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">                 A                          A
                  <span style="color:#a61717;background-color:#e3d2d2">\</span>                        /
                   B                      B
                  /                        \
                 C	                        C</code></pre></div>
<p>上面的这两种情况就是书上所说的关于双旋转的问题。解决这两种情况的方法就是先旋转B节点,先将C点与B点旋转到A点与B点相同的指向方向。然后在根据A点做对应方向的旋转。</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">     A                A                C            A              A               C
      <span style="color:#a61717;background-color:#e3d2d2">\</span>                <span style="color:#a61717;background-color:#e3d2d2">\</span>              / <span style="color:#a61717;background-color:#e3d2d2">\</span>          /                <span style="color:#a61717;background-color:#e3d2d2">\</span>             / \
       B      =&gt;        C       =&gt;   A   B        B       =&gt;         C      =&gt;   A   B
      /                  <span style="color:#a61717;background-color:#e3d2d2">\</span>                         <span style="color:#a61717;background-color:#e3d2d2">\</span>                  \
     C                    B                         C                  B
     </code></pre></div>
<p>写到这里貌似可以去开工写代码了，但是请等等。在实际的编码中碰到如下情况还是不知道到底该怎样旋转。</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">        A                                  A           
         <span style="color:#a61717;background-color:#e3d2d2">\</span>                                /
          B                              B
         / <span style="color:#a61717;background-color:#e3d2d2">\</span>                            / \
        C   D                          C   D</code></pre></div>
<p>在这两种情况中一般书上给的答案是‘判断新插入的节点到底是在左子树，还是在右子树’。然后再做对应的调整，这样确实是能解决问题的。但是在删除一个节点时，是不可能使用这种方法进行判断的。但我们可以根据树旋转的性质去解决这个问题。从上面的问题可以看出，树旋转最根本的原因就是降低树的高度。根据这个性质我们可以做进一步的分析。对不平衡的子节点去做旋转。那就是&rdquo;哪边更高我们就去将它旋转一下，将它将降低一层&rdquo;。 如果子节点两边的高度是一样的，或者更高的子节点方向与父节点一致的，那么就直接去旋转父节点。
   以上就是avl树基本的旋转过程，avl树和二叉树的插入与删除操作都是一样的。不同的是avl树在插入和删除后需要由下至上扫描并旋转整棵树以保持平衡。</p>

<div class="comments">
  <hr class="hr-middle-text" data-content="COMMENTS">
  <script src="https://utteranc.es/client.js" repo="leyafo/leyafo.github.io" issue-term="title" label="Commnets" theme="github-light" crossorigin="anonymous" async >
  </script>
</div>
    </article>
  </div>
</body>
</html>
